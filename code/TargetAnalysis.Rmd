---
title: "R Notebook for selector gene target analysis"
author: Sami Kilpinen
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    code_folding: hide
---

```{r Packages, include=FALSE}
library(tidyverse)
library(Seurat)
library(Signac)
library(qs)
library(readxl)
library(hash)
library(fgsea)
library(DBI)
library(hash)
#library(biomaRt)
library(presto)
library(purrr)
library(circlize)
library(ComplexHeatmap)
library(patchwork)
library(parallel)
library(topGO)
library(dplyr)
source("../../AuxCode/AuxFunctions.R")
```

```{r Functions}

extract_gene_enrichments <- function(ranks,gene_sets){
  # Plot enrichment and extract data
  enrichment_plot <- plotEnrichment(gene_sets, ranks) + 
    ggtitle("Enrichment Plot")
  
  # Extract the enrichment score profile data from the plot
  enrichment_data <- ggplot_build(enrichment_plot)$data[[1]]
  
  # Identify the leading and trailing edges
  positive_peak_index <- which.max(enrichment_data$y)
  negative_trough_index <- which.min(enrichment_data$y)
  
  # Ensure the trailing edge is calculated correctly
  trailing_edge_genes <- names(ranks)[(negative_trough_index + 1):length(ranks)]
  trailing_edge_genes <- trailing_edge_genes[trailing_edge_genes %in% gene_sets]
  
  # Leading edge genes
  leading_edge_genes <- names(ranks)[1:positive_peak_index]
  leading_edge_genes <- leading_edge_genes[leading_edge_genes %in% gene_sets]
  
  # Combine leading and trailing-edge genes
  combined_edges <- list(
    positive_leading_edge = leading_edge_genes,
    negative_trailing_edge = trailing_edge_genes
  )
  
  # Print combined leading and trailing-edge genes
  return(list(combined_edges=combined_edges, positive_peak_index=positive_peak_index, negative_peak_index=negative_trough_index))
}


drawTargetHeatmap <- function(DEG.res, target.genes, assay.averages,gene_name2id, gene_id2name,limits.to.plot, cell.groups){
  
  mid.upper.limit=limits.to.plot$mid.upper.limit
  mid.lower.limit=limits.to.plot$mid.lower.limit
  upper.limit=limits.to.plot$upper.limit
  lower.limit=limits.to.plot$lower.limit
  
  target.genes.in.order <- names(sort(DEG.res[target.genes], decreasing = TRUE))
Targets.expression.avg <- t(assay.averages$RNA[sapply(target.genes.in.order,function(id){gene_name2id[[id]]}),cell.groups])
colnames(Targets.expression.avg) <- sapply(colnames(Targets.expression.avg),function(id){gene_id2name[[id]]})
col_fun = colorRamp2(c(min(Targets.expression.avg), median(Targets.expression.avg),max(Targets.expression.avg)), c("white", "red","darkred"))

color_factor <- factor(
  ifelse(DEG.res[target.genes.in.order] > upper.limit, "blue",
    ifelse(DEG.res[target.genes.in.order] <= mid.lower.limit & DEG.res[target.genes.in.order] >= mid.upper.limit, "green",
      ifelse(DEG.res[target.genes.in.order] < lower.limit, "red", "white")
    )
  ),
  levels = c("red", "white", "green", "blue")
)

col_anno <- HeatmapAnnotation(target_gene_group = color_factor,
  col = list(target_gene_group = c("red" = "red", "white" = "white", "green" = "green", "blue" = "blue")),
  annotation_legend_param = list(target_gene_group = list(title = "Target gene group")))

h1 <- Heatmap(as.matrix(Targets.expression.avg), cluster_columns = FALSE,col=col_fun, show_column_names = FALSE,bottom_annotation = col_anno,heatmap_legend_param = list(title = "Target Expression"))
  return(h1)
}

mean.fxn <- function (x,pseudocount.use=1, base=2)
{
    return(log(x = rowMeans(x = expm1(x = x)) + pseudocount.use,
        base = base))
}

getTargets <- function(TF_name, CT, Cons, ft){
  targetQuery <- paste("SELECT 
    gm.gene_name,
    COUNT(CASE WHEN li.zscore > 0 THEN 1 ELSE NULL END) AS count_zscore_positive,
    COUNT(CASE WHEN li.zscore < 0 THEN 1 ELSE NULL END) AS count_zscore_negative,
    COUNT(DISTINCT li.feature) AS count_distinct_feature,
    COUNT(li.feature) AS count_feature,
    AVG(tb.PRO1_2_score) AS PRO1_2_score_average,
    AVG(tb.GA1_2_score) AS GA1_2_score_average,
    AVG(tb.GL1_2_score) AS GL1_2_score_average,
    AVG(tb.GA1_2_score) -  AVG(tb.PRO1_2_score) AS PRO1_2_GA_increase,
    AVG(tb.GL1_2_score) -  AVG(tb.PRO1_2_score) AS PRO1_2_GL_increase,
    AVG(tb.GA1_2_score) / NULLIF(AVG(tb.PRO1_2_score), 0) AS PRO1_2_GA_FT_ratio,
    AVG(tb.GL1_2_score) / NULLIF(AVG(tb.PRO1_2_score), 0) AS PRO1_2_GL_FT_ratio
FROM 
    links AS li
    JOIN tobias AS tb ON tb.features = li.feature
    JOIN CT_data AS ct ON ct.feature = tb.features
    JOIN gene_metadata AS gm ON gm.ensg_id = li.ensg_id
WHERE
    tb.TF_gene_name = '",toupper(TF_name),"'
    AND ABS(li.zscore) > 2 
    AND li.pvalue < 0.001 
    AND ct.target_gene_name = '",TF_name,"'
    AND (tb.GA1_2_bound = 1 OR tb.GL1_2_bound = 1)
    AND tb.w_mean_cons > 0.5
GROUP BY 
    gm.gene_name;",
sep="")
  
  target.data <- as_tibble(dbGetQuery(con, targetQuery))
  targets <- unique(pull(target.data, gene_name))
return(list(targets=targets, target.data=target.data))
}

do.GSEA <- function(targets,DEG.res,TF.name, comp.title){
  # lower.thr <- .25
  # upper.thr <- .75
  
  DEG.res <- arrange(DEG.res, desc(avg_log2FC))
  DEG.res.GSEA <- DEG.res$avg_log2FC
  names(DEG.res.GSEA) <- DEG.res$gene_name
  
  edges <- extract_gene_enrichments(ranks=sort(DEG.res.GSEA,decreasing=TRUE), gene_sets = targets)
  
  # upper.limit <- quantile(DEG.res$avg_log2FC,upper.thr)
  # upper.pos <- which.min(abs(DEG.res$avg_log2FC-upper.limit))
  upper.pos <- edges$positive_peak_index
  lower.pos <- edges$negative_peak_index
  # 
  # lower.limit <- quantile(DEG.res$avg_log2FC,lower.thr)
  # lower.pos <- which.min(abs(DEG.res$avg_log2FC-lower.limit))
  # 
  mid.thr.width <- .25
  width.around.zero <- round(nrow(DEG.res)*(mid.thr.width/2), digits = 0)
  zero.index <- which.min(abs(DEG.res$avg_log2FC))
  # 
  mid.lower.index <- zero.index-width.around.zero
  mid.upper.index <- zero.index+width.around.zero
  mid.lower.limit <- DEG.res$avg_log2FC[mid.lower.index]
  mid.upper.limit <- DEG.res$avg_log2FC[mid.upper.index]
  #   
  xmax.right <- nrow(DEG.res)
  # 
  limits <- list(upper.limit=upper.limit,lower.limit=lower.limit,mid.lower.limit=mid.lower.limit,mid.upper.limit=mid.upper.limit)
  
  
  p1 <- plotEnrichment(targets, DEG.res.GSEA) + ggtitle(paste(TF.name,"target enrichments in", comp.title)) + geom_rect(aes(xmin=0,xmax=upper.pos,ymin=-0.05,ymax=0.05), fill="blue", alpha=0.002) + geom_rect(aes(xmin=mid.lower.index,xmax=mid.upper.index,ymin=-0.05,ymax=0.05), fill="green", alpha=0.002) + geom_rect(aes(xmin=lower.pos,xmax=xmax.right,ymin=-0.05,ymax=0.05), fill="red", alpha=0.002)
  d1 <- DEG.res %>% dplyr::filter(gene_name %in% targets)
  
  d1$target_gene_group <- factor(
  ifelse(d1$avg_log2FC > upper.limit, "blue",
    ifelse(d1$avg_log2FC >= mid.lower.limit & d1$avg_log2FC <= mid.upper.limit, "green",
      ifelse(d1$avg_log2FC < lower.limit, "red", "white")
    )
  ),
  levels = c("red", "white", "green", "blue")
)
  
  return(list(p1=p1,d1=d1,limits=limits))
}
```

```{r Setting variables, include=FALSE}
cores <- 6
con <- DBI::dbConnect(RSQLite::SQLite(), dbname = "~/Workspace/TOBIAS.dr.h12_140524.sqlite")
options(timeout = 30000)

plot_loc <- "~/OneDrive - University of Helsinki/E12R1 project/Manuscript I - Regulation of Tal1 dependent rV2 lineage bifurcation/Figures/plots/training/"
```

# Target counts {.tabset}

## With C&T True and Cons True ft True

```{r Set3}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2","Sox4","Klf17","Myc")
targetGenes.set.3 <- lapply(TF_names,getTargets,CT=TRUE, Cons=TRUE, ft=TRUE)
names(targetGenes.set.3) <- TF_names
sapply(targetGenes.set.3,function(p){length(p$targets)})
```


# GSEA analysis of target genes {.tabset}

```{r Reading rV2 data, include=FALSE}
rV2.dataset <- qread("../scATAC_data/nmm_rV2_subset_relabeled_031023_links.qs", nthreads = cores)

rV2.dataset$rv2.lineage_re <- case_when(
  rV2.dataset$rv2.lineage %in% "PRO1" ~ "PRO1_2",
  rV2.dataset$rv2.lineage %in% "PRO2" ~ "PRO1_2",
  rV2.dataset$rv2.lineage %in% "GA1" ~ "GA1_2",
  rV2.dataset$rv2.lineage %in% "GA2" ~ "GA1_2",
  rV2.dataset$rv2.lineage %in% "GA3" ~ "GA3_4",
  rV2.dataset$rv2.lineage %in% "GA4" ~ "GA3_4",
  rV2.dataset$rv2.lineage %in% "GA5" ~ "GA5_6",
  rV2.dataset$rv2.lineage %in% "GA6" ~ "GA5_6",
  rV2.dataset$rv2.lineage %in% "CO1" ~ "CO1_2",
  rV2.dataset$rv2.lineage %in% "CO2" ~ "CO1_2",
  rV2.dataset$rv2.lineage %in% "GL1" ~ "GL1_2",
  rV2.dataset$rv2.lineage %in% "GL2" ~ "GL1_2",
  rV2.dataset$rv2.lineage %in% "GL3" ~ "GL3_4",
  rV2.dataset$rv2.lineage %in% "GL4" ~ "GL3_4",
  rV2.dataset$rv2.lineage %in% "GL5" ~ "GL5",
)

DefaultAssay(rV2.dataset) <- "RNA"

gene_id2name <- hash(rownames(rV2.dataset[['RNA']][[]]),rV2.dataset[['RNA']][[]][,1])
gene_name2id <- hash(rV2.dataset[['RNA']][[]][,1],rownames(rV2.dataset[['RNA']][[]]))
```

```{r reading Serot data and merging, warning=FALSE}
serot.dataset <- qread("../serot/sero_relabeled_201123_links.qs", nthreads = cores)
merged.datasets <- merge(rV2.dataset,serot.dataset)

merged.datasets$merged.groups <- factor(ifelse(is.na(merged.datasets$sero.lineage), merged.datasets$rv2.lineage_re, merged.datasets$sero.lineage), levels=c("PRO1_2","CO1_2","GA1_2","GA3_4","GA5_6","GL1_2","GL3_4","GL5","SR1","SR2","SR3"))

merged.datasets$merged.groups <- fct_collapse(merged.datasets$merged.groups, SR2_3 = c("SR2", "SR3"))

gene_id2name <- hash(rownames(rV2.dataset[['RNA']][[]]),rV2.dataset[['RNA']][[]][,1])
gene_name2id <- hash(rV2.dataset[['RNA']][[]][,1],rownames(rV2.dataset[['RNA']][[]]))
  
DefaultAssay(merged.datasets) <- "RNA"
```

```{r Calculating averages and DEG for GA/GL axis, include=FALSE}
assay.averages <- AverageExpression(rV2.dataset,group.by = "rv2.lineage_re")

Idents(rV2.dataset) <- rV2.dataset$rv2.lineage_re
DEG.res <- FindMarkers(rV2.dataset, ident.1="GA1_2", ident.2 = "GL1_2",logfc.threshold=0, assay = "RNA", slot="data", mean.fxn=mean.fxn) %>% rownames_to_column(var="ensg_id") %>% as_tibble() %>% dplyr::filter(p_val_adj<0.01)

colnames(assay.averages$RNA) <- str_replace_all(colnames(assay.averages$RNA), pattern = "-", replacement = "_")

DEG.res$GL1_2_exp_avg_log2 <- log(assay.averages$RNA[DEG.res$ensg_id,"GL1_2"]+1,base=2)
DEG.res$GA1_2_exp_avg_log2 <- log(assay.averages$RNA[DEG.res$ensg_id,"GA1_2"]+1, base=2)
DEG.res$GL1_2_exp_avg <- assay.averages$RNA[DEG.res$ensg_id,"GL1_2"]
DEG.res$GA1_2_exp_avg <- assay.averages$RNA[DEG.res$ensg_id,"GA1_2"]
DEG.res$gene_name <- sapply(DEG.res$ensg_id,function(ensg_id){hash::values(gene_id2name[ensg_id])})
DEG.res <- DEG.res %>% mutate(across(where(is.numeric), \(x) round(x, digits = 8))) %>% arrange(avg_log2FC)

DEG.res.GSEA <- DEG.res$avg_log2FC
names(DEG.res.GSEA) <- DEG.res$gene_name
```

```{r Calculating averages and DEG for GA/Serot axis, include=FALSE}
assay.averages <- AverageExpression(merged.datasets,group.by = "merged.groups")

Idents(merged.datasets) <- merged.datasets$merged.groups
DEG.res.GASR <- FindMarkers(merged.datasets, ident.1="GA1_2", ident.2 = "SR2_3",logfc.threshold=0, assay = "RNA", slot="data", mean.fxn=mean.fxn) %>% rownames_to_column(var="ensg_id") %>% as_tibble() 
#%>% dplyr::filter(p_val_adj<0.01)

colnames(assay.averages$RNA) <- str_replace_all(colnames(assay.averages$RNA), pattern = "-", replacement = "_")

DEG.res.GASR$SR2_3_exp_avg_log2 <- log(assay.averages$RNA[DEG.res.GASR$ensg_id,"SR2_3"]+1,base=2)
DEG.res.GASR$GA1_2_exp_avg_log2 <- log(assay.averages$RNA[DEG.res.GASR$ensg_id,"GA1_2"]+1, base=2)
DEG.res.GASR$SR2_3_exp_avg <- assay.averages$RNA[DEG.res.GASR$ensg_id,"SR2_3"]
DEG.res.GASR$GA1_2_exp_avg <- assay.averages$RNA[DEG.res.GASR$ensg_id,"GA1_2"]
DEG.res.GASR$gene_name <- sapply(DEG.res.GASR$ensg_id,function(ensg_id){hash::values(gene_id2name[ensg_id])})
DEG.res.GASR <- DEG.res.GASR %>% mutate(across(where(is.numeric), \(x) round(x, digits = 8))) %>% arrange(avg_log2FC)

DEG.res.GSEA.GASR <- DEG.res.GASR$avg_log2FC
names(DEG.res.GSEA.GASR) <- DEG.res.GASR$gene_name
```

```{r Correlations between target genes and selector genes, warning=FALSE}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")

PRO_GA.subset <- subset(merged.datasets, idents=c("PRO1_2","CO1_2","GA1_2"))
PRO_GL.subset <- subset(merged.datasets, idents=c("PRO1_2","CO1_2","GL1_2"))
PRO_SR.subset <- subset(merged.datasets, idents=c("PRO1_2","SR1","SR2_3"))

# PRO_GA.correlations 
expression_matrix <- GetAssayData(PRO_GA.subset, slot = "data")
TF.cors.PRO_GA <- lapply(TF_names,function(TF){
    correlations <- mclapply(1:nrow(expression_matrix), function(i) {
      gene_expr <- expression_matrix[i,]
      if (sd(gene_expr) == 0) {
        return(NA)
      } else {
        cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
      }
    }, mc.cores=8)
    names(correlations) <- rownames(expression_matrix)
    return(correlations)
})
names(TF.cors.PRO_GA) <- TF_names

# PRO_GL.correlations 
expression_matrix <- GetAssayData(PRO_GL.subset, slot = "data")
TF.cors.PRO_GL <- lapply(TF_names,function(TF){
    correlations <- mclapply(1:nrow(expression_matrix), function(i) {
      gene_expr <- expression_matrix[i,]
      if (sd(gene_expr) == 0) {
        return(NA)
      } else {
        cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
      }
    }, mc.cores=8)
    names(correlations) <- rownames(expression_matrix)
    return(correlations)
})
names(TF.cors.PRO_GL) <- TF_names

# PRO_SR.correlations 
expression_matrix <- GetAssayData(PRO_SR.subset, slot = "data")
TF.cors.PRO_SR <- lapply(TF_names,function(TF){
    correlations <- mclapply(1:nrow(expression_matrix), function(i) {
      gene_expr <- expression_matrix[i,]
      if (sd(gene_expr) == 0) {
        return(NA)
      } else {
        cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
      }
    }, mc.cores=8)
    names(correlations) <- rownames(expression_matrix)
    return(correlations)
})
names(TF.cors.PRO_SR) <- TF_names

qsave(TF.cors.PRO_GA,"../analysis/TF.cors.PRO_GA.qs", nthreads = cores)
qsave(TF.cors.PRO_GL,"../analysis/TF.cors.PRO_GL.qs", nthreads = cores)
qsave(TF.cors.PRO_SR,"../analysis/TF.cors.PRO_SR.qs", nthreads = cores)
```

## GSEA {.tabset}

### GA/GL

```{r GA/GL GSEA for Set 3 plots, warning=FALSE}
set1.GSEA <- invisible(lapply(TF_names, function(target){do.GSEA(targets=targetGenes.set.3[[target]]$targets,DEG.res=DEG.res,TF.name=target, comp.title="GA/GL DEG")}))

# limits <- sapply(set1.GSEA,function(p){p$limits})
# colnames(limits) <- TF_names
# print(limits)
# 
# upper.limit <- set1.GSEA[[1]]$limits$upper.limit
# lower.limit <- set1.GSEA[[1]]$limits$lower.limit
# mid.upper.limit <- set1.GSEA[[1]]$limits$mid.upper.limit
# mid.lower.limit <- set1.GSEA[[1]]$limits$mid.lower.limit
# 
# limits.to.plot <- list(upper.limit=upper.limit,lower.limit=lower.limit,mid.lower.limit=mid.lower.limit,mid.upper.limit=mid.upper.limit)

for (i in 1:length(set1.GSEA)){
    h1 <- drawTargetHeatmap(DEG.res=DEG.res.GSEA, set1.GSEA[[i]]$d1$gene_name,assay.averages=assay.averages,gene_name2id=gene_name2id, gene_id2name=gene_id2name,limits.to.plot=limits.to.plot, cell.groups=c("PRO1_2","CO1_2","GA1_2","GL1_2"))
    heatmap_grob <- grid::grid.grabExpr(draw(h1))
    p1 <- set1.GSEA[[i]]$p1
  print(plot_grid(plotlist = list(p1, heatmap_grob), labels = c('A', 'B'), label_size = 12, ncol = 1, nrow = 2))
}
```

```{r GA/GL GSEA for Set 3 tables, warning=FALSE}

tmp.1 <- lapply(targetGenes.set.3,function(p){p$targets})
names(tmp.1) <- names(targetGenes.set.3)
results <- fgsea(pathways = tmp.1, 
                 stats = DEG.res.GSEA, 
                 minSize = 5,  # Minimum size of a gene set to be considered
                 maxSize = 5000) # Maximum size of a gene set to be considered
results <- results %>% mutate(across(where(is.numeric), \(x) round(x, digits=3)))
create_dt(results)

DEG.res.subset <- lapply(targetGenes.set.3, function(p){
  left_join(filter(DEG.res, gene_name %in% p$targets),p$target.data, by=c("gene_name"="gene_name"))
  })

combined_tibble <- map_dfr(DEG.res.subset, ~ .x, .id = "TF")

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.GA = TF.cors.PRO_GA[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.GL = TF.cors.PRO_GL[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.SR = TF.cors.PRO_SR[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>% mutate_if(is.numeric, round, digits=3)

create_dt(filter(combined_tibble, TF=="Tal1"))
create_dt(filter(combined_tibble, TF=="Gata2"))
create_dt(filter(combined_tibble, TF=="Gata3"))
create_dt(filter(combined_tibble, TF=="Vsx2"))
```

### GA/SR

```{r GA/SR GSEA for Set 3 plots, warning=FALSE, echo=FALSE}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")
set1.GSEA <- invisible(lapply(TF_names, function(target){do.GSEA(targets=targetGenes.set.3[[target]]$targets,DEG.res=DEG.res.GASR,TF.name=target,comp.title="GA/SR DEG")}))


edges <- extract_gene_enrichments(ranks=sort(DEG.res.GSEA.GASR,decreasing=TRUE), gene_sets = targetGenes.set.3[["Tal1"]]$targets)

limits <- sapply(set1.GSEA,function(p){p$limits})
colnames(limits) <- TF_names
print(limits)

upper.limit <- set1.GSEA[[1]]$limits$upper.limit
lower.limit <- set1.GSEA[[1]]$limits$lower.limit
mid.upper.limit <- set1.GSEA[[1]]$limits$mid.upper.limit
mid.lower.limit <- set1.GSEA[[1]]$limits$mid.lower.limit

limits.to.plot <- list(upper.limit=upper.limit,lower.limit=lower.limit,mid.lower.limit=mid.lower.limit,mid.upper.limit=mid.upper.limit)

for (i in 1:length(set1.GSEA)){
    h1 <- drawTargetHeatmap(DEG.res=DEG.res.GSEA.GASR, set1.GSEA[[i]]$d1$gene_name,assay.averages=assay.averages,gene_name2id=gene_name2id, gene_id2name=gene_id2name,limits.to.plot=limits.to.plot,cell.groups=c("PRO1_2","CO1_2","GA1_2","SR1","SR2_3"))
    heatmap_grob <- grid::grid.grabExpr(draw(h1))
    p1 <- set1.GSEA[[i]]$p1
  print(plot_grid(plotlist = list(p1, heatmap_grob), labels = c('A', 'B'), label_size = 12, ncol = 1, nrow = 2))
}
```

```{r GA/SR GSEA for Set 3 tables, warning=FALSE, echo=FALSE}
tmp.1 <- lapply(targetGenes.set.3,function(p){p$targets})
names(tmp.1) <- names(targetGenes.set.3)
results <- fgsea(pathways = tmp.1, 
                 stats = DEG.res.GSEA.GASR, 
                 minSize = 5,  # Minimum size of a gene set to be considered
                 maxSize = 5000) # Maximum size of a gene set to be considered
results <- results %>% mutate(across(where(is.numeric), \(x) round(x, digits=3)))
create_dt(results)

DEG.res.subset <- lapply(targetGenes.set.3, function(p){
  left_join(filter(DEG.res.GASR, gene_name %in% p$targets),p$target.data, by=c("gene_name"="gene_name"))
  })

combined_tibble <- map_dfr(DEG.res.subset, ~ .x, .id = "TF")

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.GA = TF.cors.PRO_GA[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.GL = TF.cors.PRO_GL[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.SR = TF.cors.PRO_SR[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>% mutate_if(is.numeric, round, digits=3)

create_dt(filter(combined_tibble, TF=="Tal1"))
create_dt(filter(combined_tibble, TF=="Gata2"))
create_dt(filter(combined_tibble, TF=="Gata3"))
create_dt(filter(combined_tibble, TF=="Vsx2"))
```

# FT-score analysis {.tabset}

## Counts & densities (Tal1)

```{r}
Tal1.exp <- as_tibble(dbGetQuery(con, 'SELECT exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Tal1");')) %>% distinct()

Tal1.tb.data <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("TAL1") AND ac.features=tb.features;')) %>% distinct()

Tal1.tb.data.ct <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("TAL1") AND ct.feature=tb.features AND ct.target_gene_name="Tal1" AND ac.features=tb.features;')) %>% distinct()
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
Tal1.tb.data <- Tal1.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
Tal1.tb.data <- Tal1.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
Tal1.tb.data.ct <- Tal1.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
Tal1.tb.data.ct <- Tal1.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### Tal1 TFBS data C&T False
```{r}
Tal1.tb.data
```

### Tal1 TFBS data C&T True
```{r}
Tal1.tb.data.ct
```

```{r, include=FALSE}
Tal1.cor.tests <- apply(as.matrix(Tal1.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(Tal1.exp), y=r)
})

Tal1.cor.li <- sapply(Tal1.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

Tal1.tb.data$cor.test <- Tal1.cor.li

Tal1.cor.tests <- apply(as.matrix(Tal1.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(Tal1.exp), y=r)
})

Tal1.cor.ct.li <- sapply(Tal1.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

Tal1.tb.data.ct$cor.test <- Tal1.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with Tal1 average expression (please note, only three datapoints)

```{r}
results <- Tal1.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with Tal1 average expression (please note, only three datapoints)

```{r}
results <- Tal1.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```

## Counts & densities (Gata2)

```{r}
gene.exp <- as_tibble(dbGetQuery(con, 'SELECT exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Gata2");')) %>% distinct()

gene.tb.data <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("GATA2") AND ac.features=tb.features;')) %>% distinct()

gene.tb.data.ct <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("GATA2") AND ct.feature=tb.features AND ct.target_gene_name="Gata2" AND ac.features=tb.features;')) %>% distinct()
```


```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data <- gene.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data <- gene.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data.ct <- gene.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data.ct <- gene.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### gene TFBS data C&T False
```{r}
gene.tb.data
```

### gene TFBS data C&T True
```{r}
gene.tb.data.ct
```

```{r, include=FALSE}
gene.cor.tests <- apply(as.matrix(gene.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data$cor.test <- gene.cor.li

gene.cor.tests <- apply(as.matrix(gene.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.ct.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data.ct$cor.test <- gene.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```


## Counts & densities (Gata3)

```{r}
gene.exp <- as_tibble(dbGetQuery(con, 'SELECT exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Gata3");')) %>% distinct()

gene.tb.data <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("GATA3") AND ac.features=tb.features;')) %>% distinct()

gene.tb.data.ct <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("GATA3") AND ct.feature=tb.features AND ct.target_gene_name="Gata3" AND ac.features=tb.features;')) %>% distinct()
```


```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data <- gene.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data <- gene.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data.ct <- gene.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data.ct <- gene.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### gene TFBS data C&T False
```{r}
gene.tb.data
```

### gene TFBS data C&T True
```{r}
gene.tb.data.ct
```

```{r, include=FALSE}
gene.cor.tests <- apply(as.matrix(gene.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data$cor.test <- gene.cor.li

gene.cor.tests <- apply(as.matrix(gene.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.ct.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data.ct$cor.test <- gene.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```

## Counts & densities (Vsx2)

```{r}
gene.exp <- as_tibble(dbGetQuery(con, 'SELECT exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Vsx2");')) %>% distinct()

gene.tb.data <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("VSX2") AND ac.features=tb.features;')) %>% distinct()

gene.tb.data.ct <- as_tibble(dbGetQuery(con, 'SELECT tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("VSX2") AND ct.feature=tb.features AND ct.target_gene_name="Vsx2" AND ac.features=tb.features;')) %>% distinct()
```


```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data <- gene.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data <- gene.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data.ct <- gene.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data.ct <- gene.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### gene TFBS data C&T False
```{r}
gene.tb.data
```

### gene TFBS data C&T True
```{r}
gene.tb.data.ct
```

```{r, include=FALSE}
gene.cor.tests <- apply(as.matrix(gene.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data$cor.test <- gene.cor.li

gene.cor.tests <- apply(as.matrix(gene.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.ct.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data.ct$cor.test <- gene.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```

<!-- # GO enrichments 25-25-25 among target genes (C&T overlap incl.) {.tabset} -->

<!-- ```{r Connect Ensembl to fetch GO and set thresholds} -->
<!-- # Connect to the Ensembl database -->
<!-- ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl", host="https://nov2020.archive.ensembl.org") -->
<!-- gene_names_with_go <- getBM(attributes = c('external_gene_name', 'go_id'), -->
<!--                        filters = 'with_go', # This dplyr::filter is to only fetch genes with GO IDs -->
<!--                        values = TRUE, -->
<!--                        mart = ensembl) -->
<!-- # Split the data.frame into a list where each element is a character vector of GO IDs, -->
<!-- # and the names of the list elements are the Ensembl gene IDs -->
<!-- geneID2GO <- split(gene_names_with_go$go_id, gene_names_with_go$external_gene_name) -->
<!-- GO2geneID <- split(gene_names_with_go$external_gene_name,gene_names_with_go$go_id) -->
<!-- # Optionally, you can remove genes with no GO IDs if any exist -->
<!-- geneID2GO <- geneID2GO[sapply(geneID2GO, length) > 0] -->
<!-- ``` -->

<!-- ## Tal1 targets -->

<!-- ### Up in GA -->

<!-- ```{r} -->
<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Tal1, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC>upper.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->
<!-- ### Neutral -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Tal1, gene_name), DEG.res$gene_name[mid.lower.index:mid.upper.index]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ### Up in GL -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Tal1, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC<lower.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ## Gata2 targets -->

<!-- ### Up in GA -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Gata2, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC>upper.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->
<!-- ### Neutral -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Gata2, gene_name), DEG.res$gene_name[mid.lower.index:mid.upper.index]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ### Up in GL -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Gata2, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC<lower.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->


<!-- ## Gata3 targets -->

<!-- ### Up in GA -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Gata3, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC>upper.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->
<!-- ### Neutral -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Gata3, gene_name), DEG.res$gene_name[mid.lower.index:mid.upper.index]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ### Up in GL -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Gata3, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC<lower.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->



<!-- ## Vsx2 targets -->

<!-- ### Up in GA -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Vsx2, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC>upper.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ### Neutral -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Vsx2, gene_name), DEG.res$gene_name[mid.lower.index:mid.upper.index]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ### Up in GL -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Vsx2, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC<lower.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->


<!-- ## Sox4 targets -->

<!-- ### Up in GA -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Sox4, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC>upper.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->
<!-- ### Neutral -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Sox4, gene_name), DEG.res$gene_name[mid.lower.index:mid.upper.index]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

<!-- ### Up in GL -->

<!-- ```{r} -->
<!-- allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]) -->

<!-- geneList.fac <- as.factor(ifelse(allGenes.list %in% intersect(pull(targets.Sox4, gene_name), DEG.res$gene_name[DEG.res$avg_log2FC<lower.limit]), 1,0)) -->
<!-- names(geneList.fac) <- allGenes.list -->

<!-- sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP", -->
<!-- allGenes = geneList.fac, -->
<!-- nodeSize = 5, -->
<!-- annot = annFUN.gene2GO, gene2GO = geneID2GO) -->

<!-- resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher") -->
<!-- allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 25)) -->

<!-- genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){ -->
<!--   tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata)) -->
<!--   return(paste(tmp.genes, collapse = ", ")) -->
<!--   }) -->

<!-- allRes$genes.in.classes <- genes.in.classes -->

<!-- create_dt(allRes) -->
<!-- sigGenes(sampleGOdata) -->
<!-- ``` -->

```{r}
sessionInfo()
```

