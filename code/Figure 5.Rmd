---
title: "R Notebook of Figure 5"
output: 
  null
---

```{r Packages}
library(tidyverse)
library(Seurat)
library(Signac)
library(qs)
library(readxl)
library(hash)
library(fgsea)
library(DBI)
library(hash)
library(biomaRt)
library(presto)
library(ggpubr)
library(purrr)
library(patchwork)
library(parallel)
library(umap)
library(jsonlite)
library(topGO)
library(plotly)
library(dplyr)
library(cowplot)
library(ggrepel)
library(ComplexHeatmap)
library(future)
library(circlize)
library(GenomicRanges)
source(paste(auxcode.path,"AuxFunctions.R",sep=""))
source(paste(auxcode.path,"TargetAnalysis.R",sep=""))

plot_loc<-"~/OneDrive - University of Helsinki/E12R1 project/Manuscript I - Regulation of Tal1 dependent rV2 lineage bifurcation/Figures/plots/Fig5/"
```

```{r}
rV2.data <- readRDS("/Volumes/MyBookDuo/Data/E12_rV2_DownstreamReady_nmm_.240806.Rds")

# Read the JSON Lines file
json_lines <- readLines("../metadata/H12CORE_annotation.jsonl")

# Parse each line as JSON
json_data <- lapply(json_lines, function(line) fromJSON(line, flatten = TRUE))

# Extract name and associated MOUSE gene_symbol
extract_gene_symbol <- function(data) {
  if (!is.null(data$masterlist_info$species$MOUSE$gene_symbol)) {
    list(
      name = data$name,
      gene_symbol = data$masterlist_info$species$MOUSE$gene_symbol
    )
  } else {
    NULL
  }
}

# Apply function to each parsed JSON object
result <- lapply(json_data, extract_gene_symbol)

# Remove NULL values from result (if any entries had no MOUSE gene_symbol)
result <- result[!sapply(result, is.null)]

# Optionally, convert the result to a dataframe for easier handling
result_df <- do.call(rbind.data.frame, result)
print(result_df)
```

```{r}
rV2.data.avg <- AverageExpression(rV2.data)
```

```{r}
# Apply log1p transformation to the chromvar matrix
log1p_chromvar_matrix <- log1p(chromvar_matrix)

# Define the number of top TF motifs per cell group
top_N <- 10  # You can change this to the number of top motifs you need

# Function to extract the top N motifs for each cell group based on log1p transformed data
extract_top_motifs <- function(chromvar_column, N = top_N) {
  # Sort the motifs by their log1p chromvar score for the given cell group and select the top N
  sorted_indices <- order(chromvar_column, decreasing = TRUE)[1:N]
  return(sorted_indices)
}

# Initialize an empty list to store the indices of top motifs for each cell group
top_motif_indices <- list()

# Loop through each cell group (column in the log1p chromvar matrix) and extract the top N motifs
for (cell_group in colnames(log1p_chromvar_matrix)) {
  top_motif_indices[[cell_group]] <- extract_top_motifs(log1p_chromvar_matrix[, cell_group])
}

# Get the union of all top motif indices (i.e., all unique top motifs across all cell groups)
unique_top_motif_indices <- unique(unlist(top_motif_indices))

# Subset the log1p transformed chromvar matrix to only include these top motifs
heatmap_motifs_data <- log1p_chromvar_matrix[unique_top_motif_indices, , drop = FALSE]

# Transpose the matrix to have motifs on the x-axis and cell groups on the y-axis
heatmap_motifs_data <- t(heatmap_motifs_data)

# Step 5: Define the desired order for the y-axis (cell groups)
desired_order <- c("PRO1", "PRO2", "CO1", "CO2", 
                   "GA1", "GA2", "GA3", "GA4", "GA5", "GA6", 
                   "GL1", "GL2", "GL3", "GL4", "GL5")

# Reorder the rows of the heatmap_motifs_data to match the desired order
heatmap_motifs_data <- heatmap_motifs_data[desired_order, , drop = FALSE]

pdf(width = 12, height = 5, file=paste(plot_loc,"Figure5_TF_motifs.pdf",sep=""))
# Draw heatmap for the top N motifs per cell group based on log1p transformed data
Heatmap(heatmap_motifs_data,
        name = "chromvar (log1p, motifs)",
        column_names_gp = gpar(fontsize = 10),  # Adjust column (motifs) font size
        row_names_gp = gpar(fontsize = 10),  # Adjust row (cell groups) font size
        show_column_names = TRUE,
        show_row_names = TRUE,
        cluster_rows = FALSE,  # Don't cluster rows (cell groups) to preserve the order
        cluster_columns = TRUE)  # Cluster columns (motifs)
dev.off()
```


```{r}
# Step 1: Ensure the TF names are unique and valid
valid_tfs <- unique(valid_tfs)  # Ensure only unique TFs

# Step 2: Aggregate the chromvar values by unique TFs
# Initialize a list to store aggregated chromvar values for each TF
tf_scores <- list()

# Loop through each unique TF and calculate the average chromvar score for motifs that map to it
for (tf in valid_tfs) {
  tf_motif_indices <- which(valid_tfs == tf)
  
  # Calculate the average chromvar score across all motifs that map to this TF
  tf_scores[[tf]] <- rowMeans(heatmap_motifs_data[, tf_motif_indices, drop = FALSE])
}

# Convert the list of aggregated TF scores into a matrix
heatmap_data <- do.call(cbind, tf_scores)

# Step 3: Ensure that the **columns** of heatmap_data (cell groups) are reordered according to the desired order of cell groups
# The columns represent the cell groups, so we reorder them based on desired_order
heatmap_data <- heatmap_data[desired_order, ,drop = FALSE]

# Step 4: Draw the heatmap with TFs on the **x-axis** and cell groups on the **y-axis**
# No transpose needed here since `heatmap_data` is already in the correct orientation
pdf(width = 10, height = 5, file=paste(plot_loc,"Figure5_TFs.pdf",sep=""))
Heatmap(heatmap_data,
        name = "chromvar (log1p, TFs)",
        column_names_gp = gpar(fontsize = 10),  # Adjust TF (now columns) font size
        row_names_gp = gpar(fontsize = 10),  # Adjust cell group (now rows) font size
        show_column_names = TRUE,
        show_row_names = TRUE,
        cluster_rows = FALSE,  # Don't cluster rows (cell groups) to preserve the order
        cluster_columns = TRUE)  # Cluster columns (TFs)
dev.off()
```

```{r}
# Load matrixStats package for rowMaxs
library(matrixStats)

# Step 1: Ensure the TF names are unique and valid
valid_tfs <- unique(valid_tfs)  # Ensure only unique TFs

# Step 2: Aggregate the chromvar values by taking the maximum across motifs for each TF
# Initialize a list to store aggregated chromvar values for each TF
tf_scores <- list()

# Loop through each unique TF and calculate the maximum chromvar score for motifs that map to it
for (tf in valid_tfs) {
  tf_motif_indices <- which(valid_tfs == tf)
  
  # Calculate the maximum chromvar score across all motifs that map to this TF
  tf_scores[[tf]] <- rowMaxs(as.matrix(heatmap_motifs_data[, tf_motif_indices, drop = FALSE]))
}

# Convert the list of aggregated TF scores into a matrix
heatmap_data <- do.call(cbind, tf_scores)

# Set the row names back, as rowMaxs does not retain names
rownames(heatmap_data) <- rownames(heatmap_motifs_data)

# Step 3: Ensure that the **rows** of heatmap_data (cell groups) are reordered according to the desired order of cell groups
heatmap_data <- heatmap_data[desired_order, , drop = FALSE]

pdf(width = 10, height = 5, file=paste(plot_loc,"Figure5_TFs_max.pdf",sep=""))
# Step 4: Draw the heatmap with TFs on the **x-axis** and cell groups on the **y-axis**
Heatmap(heatmap_data,
        name = "chromvar (log1p, TFs, max)",
        column_names_gp = gpar(fontsize = 10),  # Adjust TF (now columns) font size
        row_names_gp = gpar(fontsize = 10),  # Adjust cell group (now rows) font size
        show_column_names = TRUE,
        show_row_names = TRUE,
        cluster_rows = FALSE,  # Don't cluster rows (cell groups) to preserve the order
        cluster_columns = TRUE)  # Cluster columns (TFs)
dev.off()
```

```{r}
# Access the chromvar and RNA data from rV2.data.avg
chromvar_data <- rV2.data.avg$chromvar  # Chromvar assay
rna_data <- rV2.data.avg$RNA  # RNA assay

# Assuming result_df is the TF motif to TF mapping, as in previous codes
motif_to_tf <- setNames(result_df$gene_symbol, result_df$name)

# Function to calculate correlation between chromvar and RNA expression
correlation.cell.all <- sapply(1:nrow(chromvar_data), function(i) {
  motif_name <- rownames(chromvar_data)[i]
  
  # Map the motif name to the corresponding TF using motif_to_tf
  gene_symbol <- motif_to_tf[motif_name]
  
  # If the gene symbol exists, use it to fetch RNA data
  if (!is.na(gene_symbol)) {
    # TODO: Change gene mapping between symbol and ensg!!
    rnadata <- rna_data[which(rownames(rna_data) == gene_symbol), ]
  } else {
    return(NA)  # Return NA if no matching gene symbol
  }
  
  # Chromvar data for the current motif
  motifdata <- chromvar_data[i, ]
  
  # Perform the correlation test if both RNA and chromvar data are numeric
  if (is.numeric(rnadata) && length(rnadata) == length(motifdata)) {
    correlation.test <- cor.test(motifdata, rnadata, method = "spearman")
    return(correlation.test$estimate)  # Return the correlation value
  } else {
    return(NA)
  }
})

# Calculating p-values in a similar manner
correlation.cell.pvalue <- sapply(1:nrow(chromvar_data), function(i) {
  motif_name <- rownames(chromvar_data)[i]
  
  # Map the motif name to the corresponding TF using motif_to_tf
  gene_symbol <- motif_to_tf[motif_name]
  
  # If the gene symbol exists, use it to fetch RNA data
  if (!is.na(gene_symbol)) {
    rnadata <- rna_data[which(rownames(rna_data) == gene_symbol), ]
  } else {
    return(NA)  # Return NA if no matching gene symbol
  }
  
  # Chromvar data for the current motif
  motifdata <- chromvar_data[i, ]
  
  # Perform the correlation test if both RNA and chromvar data are numeric
  if (is.numeric(rnadata) && length(rnadata) == length(motifdata)) {
    correlation.test <- cor.test(motifdata, rnadata, method = "spearman")
    return(correlation.test$p.value)  # Return the p-value
  } else {
    return(NA)
  }
})

# Combine the correlation and p-value results into a tibble
correlation.cell.both <- cbind(correlation.cell.all, correlation.cell.pvalue)
cortibble.all <- as_tibble(cbind(rownames(chromvar_data), correlation.cell.both))
colnames(cortibble.all) <- c("motif", "correlation", "p_value")

# Convert correlation and p-value to numeric
cortibble.all$correlation <- as.numeric(cortibble.all$correlation)
cortibble.all$p_value <- as.numeric(cortibble.all$p_value)

# Print the result
print(cortibble.all)
```

