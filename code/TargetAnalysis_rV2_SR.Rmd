---
title: "R Notebook for selector gene target analysis in rV2"
author: Sami Kilpinen
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    code_folding: hide
---

```{r Local settings}
source("local_settings.R")
```

```{r Packages, include=FALSE}
library(tidyverse)
library(Seurat)
library(Signac)
library(qs)
library(readxl)
library(hash)
library(fgsea)
library(DBI)
library(hash)
library(biomaRt)
library(presto)
library(ggpubr)
library(purrr)
library(patchwork)
library(parallel)
library(umap)
library(topGO)
library(plotly)
library(dplyr)
library(cowplot)
library(ggrepel)
library(future)
source(paste(auxcode.path,"AuxFunctions.R",sep=""))
source(paste(auxcode.path,"TargetAnalysis.R",sep=""))
```

```{r}
plan("multisession",workers=cores)
```

```{r Setting DBI options, include=FALSE}
con <- DBI::dbConnect(RSQLite::SQLite(), dbname=paste(db.path,dbname.rV2,sep=""))
con.sr <- DBI::dbConnect(RSQLite::SQLite(), dbname = paste(db.path,dbname.sr,sep=""))
options(timeout = 30000)
```

```{r}
plot_loc<-"~/OneDrive - University of Helsinki/E12R1 project/Manuscript I - Regulation of Tal1 dependent rV2 lineage bifurcation/Figures/plots/Fig5/"
```

# Target counts {.tabset}

## Counts with C&T True and Cons True FT True in rV2

```{r}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")
targetGenes.set <- lapply(TF_names,getTargets_rV2,con=con)
names(targetGenes.set) <- TF_names
sapply(targetGenes.set,function(p){length(p$targets_gene_name)})
```

## Counts with C&T True and Cons True FT True in Serot

```{r}
TF_names <- c("Tal1","Gata2","Gata3")
targetGenes.set.SR <- lapply(TF_names,getTargets_SR,con=con.sr)
names(targetGenes.set.SR) <- TF_names
sapply(targetGenes.set.SR,function(p){length(p$targets_gene_name)})
```

# Feature level targets

```{r}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")
targetGenes.set.feat <- lapply(TF_names,getTargets_rV2_feature_level,con=con)
names(targetGenes.set.feat) <- TF_names
sapply(targetGenes.set.feat,function(p){length(p$targets_gene_name)})
```

```{r}
Tal1_target_granges <- StringToGRanges(targetGenes.set.feat$Tal1$target.data$feature, sep = c("-", "-"))
query <- 'SELECT chr, start, end FROM ct_data WHERE target_gene_name = "Gata2"'
Gata2_cnt <- as_tibble(dbGetQuery(con, query),.name_repair = "unique")
Gata2_granges <- makeGRangesFromDataFrame(Gata2_cnt)
query <- 'SELECT chr, start, end FROM ct_data WHERE target_gene_name = "Gata3"'
Gata3_cnt <- as_tibble(dbGetQuery(con, query),.name_repair = "unique")
Gata3_granges <- makeGRangesFromDataFrame(Gata3_cnt)
gata2_overlap <- countOverlaps(Tal1_target_granges, Gata2_granges, minoverlap = 1)
targetGenes.set.feat[["Tal1"]][["target.data"]][["Gata2_ct_overlap"]] <- replace(gata2_overlap, which(gata2_overlap > 0), 1)
gata3_overlap <- countOverlaps(Tal1_target_granges, Gata3_granges, minoverlap = 1)
targetGenes.set.feat[["Tal1"]][["target.data"]][["Gata3_ct_overlap"]] <- replace(gata3_overlap, which(gata3_overlap > 0), 1)
```


# Expression analysis of target genes {.tabset}

```{r Reading rV2 data, include=FALSE, eval=TRUE}
rV2.dataset <- qread("../scATAC_data/nmm_rV2_subset_relabeled_031023_links.qs", nthreads = cores)

rV2.dataset$rv2.lineage_re <- case_when(
  rV2.dataset$rv2.lineage %in% "PRO1" ~ "PRO1_2",
  rV2.dataset$rv2.lineage %in% "PRO2" ~ "PRO1_2",
  rV2.dataset$rv2.lineage %in% "GA1" ~ "GA1_2",
  rV2.dataset$rv2.lineage %in% "GA2" ~ "GA1_2",
  rV2.dataset$rv2.lineage %in% "GA3" ~ "GA3_4",
  rV2.dataset$rv2.lineage %in% "GA4" ~ "GA3_4",
  rV2.dataset$rv2.lineage %in% "GA5" ~ "GA5_6",
  rV2.dataset$rv2.lineage %in% "GA6" ~ "GA5_6",
  rV2.dataset$rv2.lineage %in% "CO1" ~ "CO1_2",
  rV2.dataset$rv2.lineage %in% "CO2" ~ "CO1_2",
  rV2.dataset$rv2.lineage %in% "GL1" ~ "GL1_2",
  rV2.dataset$rv2.lineage %in% "GL2" ~ "GL1_2",
  rV2.dataset$rv2.lineage %in% "GL3" ~ "GL3_4",
  rV2.dataset$rv2.lineage %in% "GL4" ~ "GL3_4",
  rV2.dataset$rv2.lineage %in% "GL5" ~ "GL5",
)

DefaultAssay(rV2.dataset) <- "RNA"

gene_id2name <- hash(rownames(rV2.dataset[['RNA']][[]]),rV2.dataset[['RNA']][[]][,1])
gene_name2id <- hash(rV2.dataset[['RNA']][[]][,1],rownames(rV2.dataset[['RNA']][[]]))
qsave(gene_id2name,file="gene_id2name.qs")
qsave(gene_name2id,file="gene_name2id.qs")
```

```{r reading Serot data and merging, warning=FALSE, eval=TRUE}
serot.dataset <- qread("../serot/sero_relabeled_201123_links.qs", nthreads = cores)
# merged.datasets <- merge(rV2.dataset,serot.dataset)
# 
# merged.datasets$merged.groups <- factor(ifelse(is.na(merged.datasets$sero.lineage), merged.datasets$rv2.lineage_re, merged.datasets$sero.lineage), levels=c("PRO1_2","CO1_2","GA1_2","GA3_4","GA5_6","GL1_2","GL3_4","GL5","SR1","SR2","SR3"))
# 
# DefaultAssay(merged.datasets) <- "RNA"
# qsave(merged.datasets, file="merged.datasets.qs",nthreads = cores)
```

```{r}
#merged.datasets <- qread(file=paste(data.path,"merged.datasets.qs",sep=""),nthreads = cores)
gene_id2name <- qread(file=paste(data.path,"gene_id2name.qs",sep=""))
gene_name2id <- qread(file=paste(data.path,"gene_name2id.qs",sep=""))
```

```{r Calculating averages and DEG for GA/GL axis, include=FALSE}
assay.averages.rV2 <- AverageExpression(rV2.dataset,group.by = "rv2.lineage_re")

Idents(rV2.dataset) <- rV2.dataset$rv2.lineage_re
DEG.res.1 <- FindMarkers(rV2.dataset, ident.1="GA1_2", ident.2 = "GL1_2",logfc.threshold=0, assay = "RNA", slot="data", mean.fxn=mean.fxn) %>% rownames_to_column(var="ensg_id") %>% as_tibble()

colnames(assay.averages.rV2$RNA) <- str_replace_all(colnames(assay.averages.rV2$RNA), pattern = "-", replacement = "_")

DEG.res.1$GL1_2_exp_avg_log2 <- log(assay.averages.rV2$RNA[DEG.res.1$ensg_id,"GL1_2"]+1,base=2)
DEG.res.1$GA1_2_exp_avg_log2 <- log(assay.averages.rV2$RNA[DEG.res.1$ensg_id,"GA1_2"]+1, base=2)
DEG.res.1$GL1_2_exp_avg <- assay.averages.rV2$RNA[DEG.res.1$ensg_id,"GL1_2"]
DEG.res.1$GA1_2_exp_avg <- assay.averages.rV2$RNA[DEG.res.1$ensg_id,"GA1_2"]
DEG.res.1$gene_name <- sapply(DEG.res.1$ensg_id,function(ensg_id){hash::values(gene_id2name[ensg_id])})
DEG.res.1 <- DEG.res.1 %>% mutate(across(where(is.numeric), \(x) round(x, digits = 8))) %>% arrange(avg_log2FC)
```

```{r Calculating averages and DEG for GA/Serot axis, include=FALSE, eval=FALSE}
assay.averages.merged <- AverageExpression(merged.datasets,group.by = "merged.groups")

Idents(merged.datasets) <- merged.datasets$merged.groups
DEG.res.2 <- FindMarkers(merged.datasets, ident.1="GA1_2", ident.2 = "SR2",logfc.threshold=0, assay = "RNA", slot="data", mean.fxn=mean.fxn) %>% rownames_to_column(var="ensg_id") %>% as_tibble()

colnames(assay.averages.merged$RNA) <- str_replace_all(colnames(assay.averages.merged$RNA), pattern = "-", replacement = "_")

DEG.res.2$SR2_3_exp_avg_log2 <- log(assay.averages.merged$RNA[DEG.res.2$ensg_id,"SR2"]+1,base=2)
DEG.res.2$GA1_2_exp_avg_log2 <- log(assay.averages.merged$RNA[DEG.res.2$ensg_id,"GA1_2"]+1, base=2)
DEG.res.2$SR2_3_exp_avg <- assay.averages.merged$RNA[DEG.res.2$ensg_id,"SR2"]
DEG.res.2$GA1_2_exp_avg <- assay.averages.merged$RNA[DEG.res.2$ensg_id,"GA1_2"]
DEG.res.2$gene_name <- sapply(DEG.res.2$ensg_id,function(ensg_id){hash::values(gene_id2name[ensg_id])})
DEG.res.2 <- DEG.res.2 %>% mutate(across(where(is.numeric), \(x) round(x, digits = 8))) %>% arrange(avg_log2FC)
```

```{r Calculating averages and DEG for SR1/SR2 axis, include=FALSE}
assay.averages.SR <- AverageExpression(serot.dataset,group.by = "sero.lineage")

Idents(serot.dataset) <- serot.dataset$sero.lineage
DEG.res.3 <- FindMarkers(serot.dataset, ident.1="SR2", ident.2 = "SR3",logfc.threshold=0, assay = "RNA", slot="data", mean.fxn=mean.fxn, min.pct = 0) %>% rownames_to_column(var="ensg_id") %>% as_tibble()

colnames(assay.averages.SR$RNA) <- str_replace_all(colnames(assay.averages.SR$RNA), pattern = "-", replacement = "_")

DEG.res.3$SR2_exp_avg_log2 <- log(assay.averages.SR$RNA[DEG.res.3$ensg_id,"SR2"]+1,base=2)
DEG.res.3$SR3_exp_avg_log2 <- log(assay.averages.SR$RNA[DEG.res.3$ensg_id,"SR3"]+1, base=2)
DEG.res.3$SR3_exp_avg <- assay.averages.SR$RNA[DEG.res.3$ensg_id,"SR3"]
DEG.res.3$SR2_exp_avg <- assay.averages.SR$RNA[DEG.res.3$ensg_id,"SR2"]
DEG.res.3$gene_name <- sapply(DEG.res.3$ensg_id,function(ensg_id){hash::values(gene_id2name[ensg_id])})
DEG.res.3 <- DEG.res.3 %>% mutate(across(where(is.numeric), \(x) round(x, digits = 8))) %>% arrange(avg_log2FC)
```

```{r Correlations between target genes and selector genes in rV2, warning=FALSE, eval=FALSE}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")

PRO_GA.subset <- subset(rV2.dataset, idents=c("PRO1_2","GA1_2"))
PRO_GL.subset <- subset(rV2.dataset, idents=c("PRO1_2","GL1_2"))

# CO_GA.correlations 
expression_matrix <- GetAssayData(PRO_GA.subset, slot = "data")
TF.cors.PRO_GA <- lapply(TF_names,function(TF){
    correlations <- mclapply(1:nrow(expression_matrix), function(i) {
      gene_expr <- expression_matrix[i,]
      if (sd(gene_expr) == 0) {
        return(NA)
      } else {
        cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
      }
    }, mc.cores=8)
    names(correlations) <- rownames(expression_matrix)
    return(correlations)
})
names(TF.cors.PRO_GA) <- TF_names

# CO_GL.correlations 
expression_matrix <- GetAssayData(PRO_GL.subset, slot = "data")
TF.cors.PRO_GL <- lapply(TF_names,function(TF){
    correlations <- mclapply(1:nrow(expression_matrix), function(i) {
      gene_expr <- expression_matrix[i,]
      if (sd(gene_expr) == 0) {
        return(NA)
      } else {
        cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
      }
    }, mc.cores=8)
    names(correlations) <- rownames(expression_matrix)
    return(correlations)
})
names(TF.cors.PRO_GL) <- TF_names

qsave(TF.cors.PRO_GA,paste(data.path,"TF.cors.PRO_GA.qs",sep=""), nthreads = cores)
qsave(TF.cors.PRO_GL,paste(data.path,"TF.cors.PRO_GL.qs",sep=""), nthreads = cores)
```

```{r Loading precalculated correlations rV2}
TF.cors.PRO_GA <- qread(paste(data.path,"TF.cors.PRO_GA.qs",sep=""), nthreads = cores)
TF.cors.PRO_GL <- qread(paste(data.path,"TF.cors.PRO_GL.qs",sep=""), nthreads = cores)
```

```{r Correlations between target genes and selector genes in SR, warning=FALSE, eval=FALSE}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")

#SR1.subset <- subset(merged.datasets, idents=c("SR1"))
SR1_3.subset <- subset(serot.dataset, idents=c("SR1","SR2","SR3"))
#SR3.subset <- subset(merged.datasets, idents=c("SR3"))

# SR1.correlations 
# expression_matrix <- GetAssayData(SR1.subset, slot = "data")
# TF.cors.SR1 <- lapply(TF_names,function(TF){
#     correlations <- mclapply(1:nrow(expression_matrix), function(i) {
#       gene_expr <- expression_matrix[i,]
#       if (sd(gene_expr) == 0) {
#         return(NA)
#       } else {
#         cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
#       }
#     }, mc.cores=8)
#     names(correlations) <- rownames(expression_matrix)
#     return(correlations)
# })
# names(TF.cors.SR1) <- TF_names

# SR2.correlations 
expression_matrix <- GetAssayData(SR1_3.subset, slot = "data", assay = "RNA")
#expression_matrix <- FetchData(serot.dataset, assay="RNA", vars=rownames("ENSMUSG00000015053","ENSMUSG00000055197"))
TF.cors.SR1_3 <- lapply(TF_names,function(TF){
    correlations <- mclapply(1:nrow(expression_matrix), function(i) {
      gene_expr <- expression_matrix[i,]
      if (sd(gene_expr) == 0) {
        return(NA)
      } else {
        cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
      }
    }, mc.cores=8)
    names(correlations) <- rownames(expression_matrix)
    return(correlations)
})
names(TF.cors.SR1_3) <- TF_names

# SR3.correlations 
# expression_matrix <- GetAssayData(SR3.subset, slot = "data")
# TF.cors.SR3 <- lapply(TF_names,function(TF){
#     correlations <- mclapply(1:nrow(expression_matrix), function(i) {
#       gene_expr <- expression_matrix[i,]
#       if (sd(gene_expr) == 0) {
#         return(NA)
#       } else {
#         cor(expression_matrix[gene_name2id[[TF]], ], gene_expr, method = "spearman")
#       }
#     }, mc.cores=8)
#     names(correlations) <- rownames(expression_matrix)
#     return(correlations)
# })
# names(TF.cors.SR3) <- TF_names

#qsave(TF.cors.SR1,paste(data.path,"TF.cors.SR1.qs",sep=""), nthreads = cores)
qsave(TF.cors.SR1_3,paste(data.path,"TF.cors.SR1_3.qs",sep=""), nthreads = cores)
#qsave(TF.cors.SR3,paste(data.path,"TF.cors.SR3.qs",sep=""), nthreads = cores)
```

```{r Loading precalculated correlations SR}
#TF.cors.SR1 <- qread(paste(data.path,"TF.cors.SR1.qs",sep=""))
TF.cors.SR1_3 <- qread(paste(data.path,"TF.cors.SR1_3.qs",sep=""))
#TF.cors.SR3 <- qread(paste(data.path,"TF.cors.SR3.qs",sep=""))
```

## rV2 target tables with GA1_2 and GL1_2 information

```{r}
DEG.res.subset <- lapply(targetGenes.set, function(p){
  full_join(filter(DEG.res.1, ensg_id %in% p$targets_gene.id) %>% dplyr::select(-gene_name),p$target.data, by=c("ensg_id"="ensg_id"))
  })

combined_tibble <- map_dfr(DEG.res.subset, ~ .x, .id = "TF")

ensg.ids <- sapply(combined_tibble$gene_name[is.na(combined_tibble$ensg_id)] ,function(p){gene_name2id[[p]]})

combined_tibble$ensg_id[is.na(combined_tibble$ensg_id)] <- ensg.ids
  
combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.GA = TF.cors.PRO_GA[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.PRO.GL = TF.cors.PRO_GL[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>% mutate_if(is.numeric, round, digits=3)

create_dt(filter(combined_tibble, TF=="Tal1"))
create_dt(filter(combined_tibble, TF=="Gata2"))
create_dt(filter(combined_tibble, TF=="Gata3"))
create_dt(filter(combined_tibble, TF=="Vsx2"))
```


```{r, eval=FALSE, fig.width=12, fig.height=12}
# Generate a series of threshold values
thresholds <- seq(0, 25, by = 1)

# Create a new data frame with an added threshold condition column
thresholded_data <- do.call(rbind, lapply(thresholds, function(b.thr) {
    combined_tibble %>%
        filter(TF == "Tal1" & TF.cor.PRO.GA > 0.55 & TF.cor.PRO.GA <= 1 & pct.1>0.1) %>%
        mutate(threshold = b.thr, 
               meets_threshold = sum_GA1_2_bound > b.thr)
}))

# Filter the combined data to only include rows that meet the threshold condition
thresholded_data <- thresholded_data %>% filter(meets_threshold)

# Create the faceted plot
plot <- ggplot(thresholded_data, aes(x = TF.cor.PRO.GA, y = PRO1_2_GA_FT_ratio)) +
    geom_point() +
    geom_smooth(method = "lm") +
    theme_minimal() +
    stat_cor(label.x = 0.65, label.y = 1.3, aes(label = after_stat(r.label)), method = "spearman") +
    facet_wrap(~ threshold, scales = "free")

# Print the plot
print(plot)
```

```{r, fig.height=18, fig.width=18, eval=FALSE}
# Filter and prepare the data
Tal1.targets <- combined_tibble %>%
  filter(TF == "Tal1"  & pct.1 > 0.5 & sum_GA1_2_bound>0 & (TF.cor.PRO.GA >0.5 | TF.cor.PRO.GA < -0.5)) %>%
  dplyr::select(gene_name, sum_GA1_2_bound, PRO1_2_GA_increase, TF.cor.PRO.GA,count_zscore_positive,count_zscore_negative) %>% mutate(pos_neg_feat=(count_zscore_positive-count_zscore_negative))

data <- Tal1.targets %>%
  select(-gene_name, -count_zscore_positive, -count_zscore_negative) %>%
  as.data.frame()
rownames(data) <- pull(Tal1.targets, gene_name)

data <- na.omit(data)
pca <- prcomp(data, scale. = TRUE, rank. = 3)

# Calculate the proportion of variance explained
pca_var <- pca$sdev^2
pve <- pca_var / sum(pca_var)

# Create a data frame for plotting
pca_var_df <- data.frame(
  Principal_Component = 1:length(pve),
  Proportion_of_Variance_Explained = pve,
  Cumulative_Proportion = cumsum(pve)
)

# Plot the elbow plot
ggplot(pca_var_df, aes(x = Principal_Component, y = Proportion_of_Variance_Explained)) +
  geom_point() +
  geom_line() +
  theme_minimal() +
  labs(title = "Elbow Plot of PCA",
       x = "Principal Component",
       y = "Proportion of Variance Explained")

pca_data <- as.data.frame(pca$x)
pca_data$gene_name <- rownames(pca_data)

# Match the TF.cor.PRO.GA values to pca_data
pca_data$TF.cor.PRO.GA <- Tal1.targets$TF.cor.PRO.GA[match(rownames(pca_data), Tal1.targets$gene_name)]
pca_data$FT_score_change_PRO_GA <- Tal1.targets$PRO1_2_GA_increase[match(rownames(pca_data), Tal1.targets$gene_name)]
pca_data$sum_GA1_2_bound <- Tal1.targets$sum_GA1_2_bound[match(rownames(pca_data), Tal1.targets$gene_name)]
pca_data$count_zscore_negative <- Tal1.targets$count_zscore_negative[match(rownames(pca_data), Tal1.targets$gene_name)]
pca_data$count_zscore_positive <- Tal1.targets$count_zscore_positive[match(rownames(pca_data), Tal1.targets$gene_name)]
pca_data$pos_neg_feat <- Tal1.targets$pos_neg_feat[match(rownames(pca_data), Tal1.targets$gene_name)]

# Create a new column for shape based on pos_neg_feat
pca_data <- pca_data %>%
  mutate(feat_link_direction = ifelse(pos_neg_feat > 0, "Positive", "Negative"))

# Define a function to identify outliers
identify_outliers <- function(pca_data, threshold = 1.2) {
  pca_data %>%
    rowwise() %>%
    mutate(outlier = (abs(PC1) > threshold | abs(PC2) > threshold)) %>%
    filter(outlier)
}

# Identify outliers
outliers <- identify_outliers(pca_data)

# Visualize PCA with names on outliers
ggplot(pca_data, aes(PC1, PC2, color = TF.cor.PRO.GA, size = FT_score_change_PRO_GA, shape=feat_link_direction)) +
  geom_point() +
  geom_text_repel(data = outliers, aes(label = gene_name), max.overlaps = Inf, force = 1.5, size = 3) +
  scale_color_gradient2(low = "blue", mid="black" ,high = "green") +
  theme_minimal() +
  labs(title = "PCA of Tal1 Targets",
       x = "Principal Component 1",
       y = "Principal Component 2",
       color = "TF.cor.PRO.GA")
```

```{r, eval=FALSE}
# Create 3D PCA plot
p <- plot_ly(pca_data, x = ~PC1, y = ~PC2, z = ~PC3, color = ~TF.cor.PRO.GA, text = ~gene_name, 
             colors = colorRamp(c("blue", "red")), type = "scatter3d", mode = "markers") %>%
  layout(title = "3D PCA Plot",
         scene = list(
           xaxis = list(title = 'PC1'),
           yaxis = list(title = 'PC2'),
           zaxis = list(title = 'PC3')
         ))

# Display the plot
p
```


```{r, eval=FALSE}
# Set seed for reproducibility
set.seed(123)

# Perform UMAP
umap_results <- umap(pca_data[, 1:3])  # Adjust the number of PCA components if needed
umap_data <- as.data.frame(umap_results$layout)
colnames(umap_data) <- c("UMAP1", "UMAP2")
umap_data$gene_name <- pca_data$gene_name
umap_data$TF.cor.PRO.GA <- pca_data$TF.cor.PRO.GA
```

```{r, eval=FALSE}
# Define a function to identify outliers
identify_outliers <- function(umap_data, threshold = 10) {
  umap_data %>%
    rowwise() %>%
    mutate(outlier = (abs(UMAP1) > threshold | abs(UMAP2) > threshold)) %>%
    filter(outlier)
}

# Identify outliers
outliers <- identify_outliers(umap_data)

# Visualize UMAP with names on outliers and coloring by TF.cor.PRO.GA
ggplot(umap_data, aes(x = UMAP1, y = UMAP2, color = TF.cor.PRO.GA)) +
  geom_point() +
  #geom_text_repel(data = outliers, aes(label = gene_name), max.overlaps = Inf) +
  scale_color_gradient(low = "blue", high = "red") +
  theme_minimal() +
  labs(title = "UMAP of PCA-Reduced Data",
       x = "UMAP Dimension 1",
       y = "UMAP Dimension 2",
       color = "TF.cor.PRO.GA")
```

```{r, eval=FALSE, fig.width=12, fig.height=12}
# Generate a series of threshold values
thresholds <- seq(0, 25, by = 1)

# Create a new data frame with an added threshold condition column
thresholded_data <- do.call(rbind, lapply(thresholds, function(b.thr) {
    combined_tibble %>%
        filter(TF == "Gata2" & TF.cor.PRO.GA > 0.65  & TF.cor.PRO.GA < 1) %>%
        mutate(threshold = b.thr, 
               meets_threshold = sum_GA1_2_bound > b.thr)
}))

# Filter the combined data to only include rows that meet the threshold condition
thresholded_data <- thresholded_data %>% filter(meets_threshold)

# Create the faceted plot
plot <- ggplot(thresholded_data, aes(x = TF.cor.PRO.GA, y = PRO1_2_GA_increase)) +
    geom_point() +
    geom_smooth(method = "lm") +
    theme_minimal() +
    stat_cor(label.x = 0.65, label.y = 1.3, aes(label = after_stat(r.label)), method = "spearman") +
    facet_wrap(~ threshold, scales = "free")

# Print the plot
print(plot)
```


```{r, eval=FALSE, fig.width=12, fig.height=12}
# Generate a series of threshold values
thresholds <- seq(0, 25, by = 1)

# Create a new data frame with an added threshold condition column
thresholded_data <- do.call(rbind, lapply(thresholds, function(b.thr) {
    combined_tibble %>%
        filter(TF == "Gata3" & TF.cor.PRO.GA > 0.65  & TF.cor.PRO.GA < 1) %>%
        mutate(threshold = b.thr, 
               meets_threshold = sum_GA1_2_bound > b.thr)
}))

# Filter the combined data to only include rows that meet the threshold condition
thresholded_data <- thresholded_data %>% filter(meets_threshold)

# Create the faceted plot
plot <- ggplot(thresholded_data, aes(x = TF.cor.PRO.GA, y = PRO1_2_GA_increase)) +
    geom_point() +
    geom_smooth(method = "lm") +
    theme_minimal() +
    stat_cor(label.x = 0.65, label.y = 1.3, aes(label = after_stat(r.label)), method = "spearman") +
    facet_wrap(~ threshold, scales = "free")

# Print the plot
print(plot)
```


```{r, eval=FALSE, fig.width=12, fig.height=12}
# Generate a series of threshold values
thresholds <- seq(0, 25, by = 1)

# Create a new data frame with an added threshold condition column
thresholded_data <- do.call(rbind, lapply(thresholds, function(b.thr) {
    combined_tibble %>%
        filter(TF == "Vsx2" & TF.cor.PRO.GL > 0.65 & TF.cor.PRO.GL < 1) %>%
        mutate(threshold = b.thr, 
               meets_threshold = sum_GL1_2_bound > b.thr)
}))

# Filter the combined data to only include rows that meet the threshold condition
thresholded_data <- thresholded_data %>% filter(meets_threshold)

# Create the faceted plot
plot <- ggplot(thresholded_data, aes(x = TF.cor.PRO.GL, y = PRO1_2_GL_increase)) +
    geom_point() +
    geom_smooth(method = "lm") +
    theme_minimal() +
    stat_cor(label.x = 0.65, label.y = 1.3, aes(label = after_stat(r.label)), method = "spearman") +
    facet_wrap(~ threshold, scales = "free")

# Print the plot
print(plot)
```

## Serot target tables with SR2 and SR3 information

```{r}
DEG.res.subset <- lapply(targetGenes.set.SR, function(p){
  full_join(filter(DEG.res.3, ensg_id %in% p$targets_gene.id) %>% dplyr::select(-gene_name), p$target.data, by=c("ensg_id"="ensg_id"))
  })

combined_tibble <- map_dfr(DEG.res.subset, ~ .x, .id = "TF")

ensg.ids <- sapply(combined_tibble$gene_name[is.na(combined_tibble$ensg_id)] ,function(p){gene_name2id[[p]]})

combined_tibble$ensg_id[is.na(combined_tibble$ensg_id)] <- ensg.ids
  
combined_tibble <- combined_tibble %>%
  rowwise() %>%
  mutate(TF.cor.SR1.SR3 = TF.cors.SR1_3[[TF]][[ensg_id]]) %>%
  ungroup()

combined_tibble <- combined_tibble %>% mutate_if(is.numeric, round, digits=3)

create_dt(filter(combined_tibble, TF=="Tal1"))
create_dt(filter(combined_tibble, TF=="Gata2"))
create_dt(filter(combined_tibble, TF=="Gata3"))
```

# GSEA analysis of target genes in rV2

## GSEA {.tabset}

```{r Data for GSEA}
DEG.res.GSEA.1 <- DEG.res.1$avg_log2FC
names(DEG.res.GSEA.1) <- DEG.res.1$gene_name
DEG.res.GSEA.1<- DEG.res.GSEA.1[DEG.res.1$p_val_adj < 0.01 & (DEG.res.1$pct.1 > 0.1 | DEG.res.1$pct.2 >0.1)]

# DEG.res.GSEA.2 <- DEG.res.2$avg_log2FC
# names(DEG.res.GSEA.2) <- DEG.res.2$gene_name
# DEG.res.GSEA.2<- DEG.res.GSEA.2[DEG.res.2$p_val_adj < 0.01 & (DEG.res.2$pct.1 > 0.1 | DEG.res.2$pct.2 >0.1)]
```

### GA/GL

```{r GA/GL GSEA plots, warning=FALSE,fig.height=5,fig.width=7}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")
set1.GSEA <- invisible(lapply(TF_names, function(target){do.GSEA(targets=targetGenes.set[[target]]$targets_gene_name,DEG.res=filter(DEG.res.1,p_val_adj < 0.01 & (pct.1 > 0.1 | pct.2 >0.1)),TF.name=target, comp.title="GA/GL DEG")}))

limits <- sapply(set1.GSEA,function(p){p$limits})
colnames(limits) <- TF_names
print(limits)

upper.limit <- set1.GSEA[[1]]$limits$upper.limit
lower.limit <- set1.GSEA[[1]]$limits$lower.limit
mid.upper.limit <- set1.GSEA[[1]]$limits$mid.upper.limit
mid.lower.limit <- set1.GSEA[[1]]$limits$mid.lower.limit

limits.to.plot <- list(upper.limit=upper.limit,lower.limit=lower.limit,mid.lower.limit=mid.lower.limit,mid.upper.limit=mid.upper.limit)

for (i in 1:length(set1.GSEA)){
  l1 <- drawTargetLinePlot(DEG.res=set1.GSEA[[i]], gene_name2id=gene_name2id, gene_id2name=gene_id2name, limits.to.plot=limits.to.plot, cell.groups=c("GA1_2","GL1_2"))
  p1 <- set1.GSEA[[i]]$p1
  p.final <- plot_grid(plotlist = list(p1, l1), labels = c('A', 'B'), label_size = 12, ncol = 1, nrow = 2)
  print(p.final)
  ggsave(plot=p.final, device = "pdf", path = plot_loc, file=paste(i,".pdf",sep=""), width = unit(12,"inch"), height = unit(6,"inch"))
}
```

```{r GA/GL GSEA for rV2 tables, warning=FALSE}
tmp.1 <- lapply(targetGenes.set,function(p){p$targets_gene_name})
names(tmp.1) <- names(targetGenes.set)
results <- fgsea(pathways = tmp.1, 
                 stats = DEG.res.GSEA.1, 
                 minSize = 5,  # Minimum size of a gene set to be considered
                 maxSize = 5000) # Maximum size of a gene set to be considered
results <- results %>% mutate(across(where(is.numeric), \(x) round(x, digits=3)))
create_dt(results)
```

```{r GA/SR GSEA plots, warning=FALSE, echo=FALSE, eval=FALSE}
TF_names <- c("Tal1","Gata2","Gata3","Vsx2")
set1.GSEA <- invisible(lapply(TF_names, function(target){do.GSEA(targets=targetGenes.set[[target]]$targets_gene_name,DEG.res=filter(DEG.res.2,p_val_adj < 0.01 & (pct.1 > 0.1 | pct.2 >0.1)),TF.name=target,comp.title="GA/SR DEG")}))

limits <- sapply(set1.GSEA,function(p){p$limits})
colnames(limits) <- TF_names
print(limits)

upper.limit <- set1.GSEA[[1]]$limits$upper.limit
lower.limit <- set1.GSEA[[1]]$limits$lower.limit
mid.upper.limit <- set1.GSEA[[1]]$limits$mid.upper.limit
mid.lower.limit <- set1.GSEA[[1]]$limits$mid.lower.limit

limits.to.plot <- list(upper.limit=upper.limit,lower.limit=lower.limit,mid.lower.limit=mid.lower.limit,mid.upper.limit=mid.upper.limit)

for (i in 1:length(set1.GSEA)){
    #h1 <- drawTargetHeatmap(DEG.res=DEG.res.GSEA.2, set1.GSEA[[i]]$d1$gene_name,assay.averages=assay.averages.merged,gene_name2id=gene_name2id, gene_id2name=gene_id2name,limits.to.plot=limits.to.plot,cell.groups=c("SR1","SR2_3"))
    #heatmap_grob <- grid::grid.grabExpr(draw(h1))
    p1 <- set1.GSEA[[i]]$p1
    print(p1)
  #print(plot_grid(plotlist = list(p1, heatmap_grob), labels = c('A', 'B'), label_size = 12, ncol = 1, nrow = 2))
}
```

```{r GA/SR GSEA tables, warning=FALSE, echo=FALSE, eval=FALSE}
tmp.1 <- lapply(targetGenes.set,function(p){p$targets_gene_name})
names(tmp.1) <- names(targetGenes.set)
results <- fgsea(pathways = tmp.1, 
                 stats = DEG.res.GSEA.2, 
                 minSize = 5,  # Minimum size of a gene set to be considered
                 maxSize = 5000) # Maximum size of a gene set to be considered
results <- results %>% mutate(across(where(is.numeric), \(x) round(x, digits=3)))
create_dt(results)
```

# GO enrichments of leading and trailing edge target genes {.tabset}

```{r Connect Ensembl to fetch GO and set thresholds}
# Connect to the Ensembl database
ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "mmusculus_gene_ensembl", host="https://nov2020.archive.ensembl.org")
gene_names_with_go <- getBM(attributes = c('external_gene_name', 'go_id'),
                       filters = 'with_go', # This dplyr::filter is to only fetch genes with GO IDs
                       values = TRUE,
                       mart = ensembl)
# Split the data.frame into a list where each element is a character vector of GO IDs,
# and the names of the list elements are the Ensembl gene IDs
geneID2GO <- split(gene_names_with_go$go_id, gene_names_with_go$external_gene_name)
GO2geneID <- split(gene_names_with_go$external_gene_name,gene_names_with_go$go_id)
# Optionally, you can remove genes with no GO IDs if any exist
geneID2GO <- geneID2GO[sapply(geneID2GO, length) > 0]
```

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm;')[,1])
```

## Tal1 targets

### Up in GA

```{r}
geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[1]]$edges$combined_edges$positive_leading_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

### Up in GL

```{r}
geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[1]]$edges$combined_edges$negative_trailing_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

## Gata2 targets

### Up in GA

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1])

geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[2]]$edges$combined_edges$positive_leading_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

### Up in GL

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1])

geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[2]]$edges$combined_edges$negative_trailing_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

## Gata3 targets

### Up in GA

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1])

geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[3]]$edges$combined_edges$positive_leading_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

### Up in GL

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1])

geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[3]]$edges$combined_edges$negative_trailing_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

## Vsx2 targets

### Up in GA

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1])

geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[4]]$edges$combined_edges$positive_leading_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

### Up in GL

```{r}
allGenes.list <- unique(dbGetQuery(con, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1])

geneList.fac <- as.factor(ifelse(allGenes.list %in% set1.GSEA[[4]]$edges$combined_edges$negative_trailing_edge, 1,0))
names(geneList.fac) <- allGenes.list

sampleGOdata <- new("topGOdata", description = "Simple session", ontology = "BP",
allGenes = geneList.fac,
nodeSize = 5,
annot = annFUN.gene2GO, gene2GO = geneID2GO)

resultFisher <- runTest(sampleGOdata, algorithm = "classic", statistic = "fisher")
allRes <- as_tibble(GenTable(sampleGOdata, classicFisher = resultFisher, ranksOf = "classicFisher", topNodes = 50))

genes.in.classes <- sapply(allRes$GO.ID,function(GO_id){
  tmp.genes <- intersect(genesInTerm(sampleGOdata, GO_id)[[1]], sigGenes(sampleGOdata))
  return(paste(tmp.genes, collapse = ", "))
  })

allRes$genes.in.classes <- genes.in.classes

create_dt(allRes)
sigGenes(sampleGOdata)
```

```{r, eval=FALSE}
# Generate a series of threshold values
thresholds <- seq(0, 25, by = 1)

# Create a new data frame with an added threshold condition column
thresholded_data <- do.call(rbind, lapply(thresholds, function(b.thr) {
    combined_tibble %>%
        filter(TF == "Gata2" & TF.cor.PRO.GA > 0.65) %>%
        mutate(threshold = b.thr, 
               meets_threshold = sum_GA1_2_bound > b.thr)
}))

# Filter the combined data to only include rows that meet the threshold condition
thresholded_data <- thresholded_data %>% filter(meets_threshold)

# Create the faceted plot
plot <- ggplot(thresholded_data, aes(x = TF.cor.PRO.GA, y = PRO1_2_GA_increase)) +
    geom_point() +
    geom_smooth(method = "lm") +
    theme_minimal() +
    stat_cor(label.x = 0.65, label.y = 1.3, aes(label = after_stat(r.label)), method = "spearman") +
    facet_wrap(~ threshold, scales = "free")

# Print the plot
print(plot)
```

```{r, eval=FALSE}
# Generate a series of threshold values
thresholds <- seq(0, 25, by = 1)

# Create a new data frame with an added threshold condition column
thresholded_data <- do.call(rbind, lapply(thresholds, function(b.thr) {
    combined_tibble %>%
        filter(TF == "Gata3" & TF.cor.PRO.GA > 0.65) %>%
        mutate(threshold = b.thr, 
               meets_threshold = sum_GA1_2_bound > b.thr)
}))

# Filter the combined data to only include rows that meet the threshold condition
thresholded_data <- thresholded_data %>% filter(meets_threshold)

# Create the faceted plot
plot <- ggplot(thresholded_data, aes(x = TF.cor.PRO.GA, y = PRO1_2_GA_increase)) +
    geom_point() +
    geom_smooth(method = "lm") +
    theme_minimal() +
    stat_cor(label.x = 0.65, label.y = 1.3, aes(label = after_stat(r.label)), method = "spearman") +
    facet_wrap(~ threshold, scales = "free")

# Print the plot
print(plot)
```

# FT-score analysis {.tabset}

## Counts & densities (Tal1)

```{r, eval=TRUE}
Tal1.exp <- as_tibble(dbGetQuery(con, 'select exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Tal1");')) %>% distinct()

Tal1.tb.data <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("TAL1") AND ac.features=tb.features;')) %>% distinct()

Tal1.tb.data.ct <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("TAL1") AND ct.feature=tb.features AND ct.target_gene_name="Tal1" AND ac.features=tb.features;')) %>% distinct()
```

```{r, eval=TRUE}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
Tal1.tb.data <- Tal1.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
Tal1.tb.data <- Tal1.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
Tal1.tb.data.ct <- Tal1.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
Tal1.tb.data.ct <- Tal1.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### Tal1 TFBS data C&T False
```{r}
Tal1.tb.data
```

### Tal1 TFBS data C&T True
```{r}
Tal1.tb.data.ct
```

```{r, include=FALSE}
Tal1.cor.tests <- apply(as.matrix(Tal1.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(Tal1.exp), y=r)
})

Tal1.cor.li <- sapply(Tal1.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

Tal1.tb.data$cor.test <- Tal1.cor.li

Tal1.cor.tests <- apply(as.matrix(Tal1.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(Tal1.exp), y=r)
})

Tal1.cor.ct.li <- sapply(Tal1.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

Tal1.tb.data.ct$cor.test <- Tal1.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with Tal1 average expression (please note, only three datapoints)

```{r}
results <- Tal1.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with Tal1 average expression (please note, only three datapoints)

```{r}
results <- Tal1.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- Tal1.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```

## Counts & densities (Gata2)

```{r}
gene.exp <- as_tibble(dbGetQuery(con, 'select exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Gata2");')) %>% distinct()

gene.tb.data <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("GATA2") AND ac.features=tb.features;')) %>% distinct()

gene.tb.data.ct <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("GATA2") AND ct.feature=tb.features AND ct.target_gene_name="Gata2" AND ac.features=tb.features;')) %>% distinct()
```


```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data <- gene.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data <- gene.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data.ct <- gene.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data.ct <- gene.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### gene TFBS data C&T False
```{r}
gene.tb.data
```

### gene TFBS data C&T True
```{r}
gene.tb.data.ct
```

```{r, include=FALSE}
gene.cor.tests <- apply(as.matrix(gene.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data$cor.test <- gene.cor.li

gene.cor.tests <- apply(as.matrix(gene.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.ct.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data.ct$cor.test <- gene.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```


## Counts & densities (Gata3)

```{r}
gene.exp <- as_tibble(dbGetQuery(con, 'select exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Gata3");')) %>% distinct()

gene.tb.data <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("GATA3") AND ac.features=tb.features;')) %>% distinct()

gene.tb.data.ct <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("GATA3") AND ct.feature=tb.features AND ct.target_gene_name="Gata3" AND ac.features=tb.features;')) %>% distinct()
```


```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data <- gene.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data <- gene.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data.ct <- gene.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data.ct <- gene.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### gene TFBS data C&T False
```{r}
gene.tb.data
```

### gene TFBS data C&T True
```{r}
gene.tb.data.ct
```

```{r, include=FALSE}
gene.cor.tests <- apply(as.matrix(gene.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data$cor.test <- gene.cor.li

gene.cor.tests <- apply(as.matrix(gene.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.ct.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data.ct$cor.test <- gene.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```

## Counts & densities (Vsx2)

```{r}
gene.exp <- as_tibble(dbGetQuery(con, 'select exp.PRO1_2,exp.CO1_2, exp.GA1_2 FROM exp, gene_metadata as gm WHERE exp.ensg_id=gm.ensg_id AND gm.gene_name IN ("Vsx2");')) %>% distinct()

gene.tb.data <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, acc as ac WHERE tb.TF_gene_name IN ("VSX2") AND ac.features=tb.features;')) %>% distinct()

gene.tb.data.ct <- as_tibble(dbGetQuery(con, 'select tb.features,tb.TF_gene_name, tb.PRO1_2_score, tb.CO1_2_score, tb.GA1_2_score, tb.PRO1_2_bound, tb.CO1_2_bound, tb.GA1_2_bound, ac.PRO1_2, ac.CO1_2, ac.GA1_2 FROM tobias as tb, CT_data as ct, acc as ac WHERE tb.TF_gene_name IN ("VSX2") AND ct.feature=tb.features AND ct.target_gene_name="Vsx2" AND ac.features=tb.features;')) %>% distinct()
```


```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data <- gene.tb.data %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data <- gene.tb.data %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

```{r}
# Calculate increases from PRO1_2 to CO1_2 and from CO1_2 to GA1_2
gene.tb.data.ct <- gene.tb.data.ct %>%
  mutate(
    Increase_PRO1_2_to_CO1_2 = CO1_2_score - PRO1_2_score,
    Increase_CO1_2_to_GA1_2 = GA1_2_score - CO1_2_score,
    Total_Increase = Increase_PRO1_2_to_CO1_2 + Increase_CO1_2_to_GA1_2,
    Ratio2PRO1_2 = ifelse(PRO1_2_score == 0, NA, (GA1_2_score / PRO1_2_score))
  )

# Rank the locations based on the total increase
gene.tb.data.ct <- gene.tb.data.ct %>%
  arrange(desc(Ratio2PRO1_2)) %>%
  mutate(Rank = row_number())  # This will give a rank with 1 being the highest increase
```

### gene TFBS data C&T False
```{r}
gene.tb.data
```

### gene TFBS data C&T True
```{r}
gene.tb.data.ct
```

```{r, include=FALSE}
gene.cor.tests <- apply(as.matrix(gene.tb.data %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data$cor.test <- gene.cor.li

gene.cor.tests <- apply(as.matrix(gene.tb.data.ct %>% dplyr::select(PRO1_2_score,CO1_2_score,GA1_2_score)),1,function(r){
  cor.test(x=unlist(gene.exp), y=r)
})

gene.cor.ct.li <- sapply(gene.cor.tests,function(p){
  if (!is.na(p$p.value) & !is.na(p$estimate)){
    if (p$p.value<0.05 & p$estimate>0.75){return(TRUE)}else{return(FALSE)}
  } else {return(FALSE)}
})

gene.tb.data.ct$cor.test <- gene.cor.ct.li
```

### C&T FALSE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### C&T TRUE
#### cor.test = >.75 correlation with p-value <0.05 with gene average expression (please note, only three datapoints)

```{r}
results <- gene.tb.data.ct %>% dplyr::select(PRO1_2_bound, CO1_2_bound, GA1_2_bound,cor.test) %>% 
  mutate(
    all_zeros = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 0),
    all_ones = if_all(c(PRO1_2_bound, CO1_2_bound, GA1_2_bound), ~ .x == 1),
    mixed = !all_zeros & !all_ones
  ) %>% group_by(cor.test) %>% 
  summarise(
    count_all_zeros = sum(all_zeros),
    count_all_ones = sum(all_ones),
    count_mixed = sum(mixed)
  )
results<- rbind(results,c("Total",colSums(results[,2:4])))
create_dt(results)
```

### Accessibility C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T False",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density.png", width = 8, height = 6, dpi = 300)
```

### Accessibility C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2, CO1_2, GA1_2) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "Accessibility")

# Create the density plot
ggplot(data_long, aes(x = Accessibility, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Chromatin Accessibility Across Cell Groups with C&T True",
       x = "Chromatin Accessibility",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Chromatin_Accessibility_Density_CT.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T False

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T False",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores.png", width = 8, height = 6, dpi = 300)
```

### FT scores C&T True

```{r}
library(ggplot2)
library(dplyr)

# Load the data
data <- gene.tb.data.ct

# Assuming 'PRO1_2', 'CO1_2', 'GA1_2' are the chromatin accessibility columns for each group
# We need to reshape the data from wide to long format to use in ggplot
data_long <- data %>%
  dplyr::select(PRO1_2_score, CO1_2_score, GA1_2_score) %>%
  pivot_longer(cols = everything(), names_to = "Cell_Group", values_to = "FT")

# Create the density plot
ggplot(data_long, aes(x = FT, fill = Cell_Group)) +
  geom_density(alpha = 0.5) +  # Adjust transparency with alpha
  labs(title = "Density Plot of Footprint scores Across Cell Groups with C&T True",
       x = "Footprint Score",
       y = "Density") +
  theme_minimal() +
  scale_fill_manual(values = c("blue", "red", "green"))  # Manually set colors for each group

# You might need to execute the following line in your R console or script environment to display the plot
ggsave("Footprint_scores_CT.png", width = 8, height = 6, dpi = 300)
```


```{r}
sessionInfo()
```

