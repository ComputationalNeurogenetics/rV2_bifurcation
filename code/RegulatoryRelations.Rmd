---
title: "R Notebook of analysis of regulatory relations from fp,acc,exp and C&T data"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    code_folding: hide
---

```{r Packages, message=FALSE}
library(rtracklayer)
library(qs)
library(Seurat)
library(Signac)
library(tidyverse)
library(GenomicRanges)
library(parallel)
library(dbplyr)
library(DBI)
library(ComplexHeatmap)
source("~/Workspace/AuxCode/TOBIAS_tools.R")
```


```{r Additional functions}
message_parallel <- function(...){
  system(sprintf('echo "\n%s\n"', paste0(..., collapse="")))
}
```

```{r Connection to SQLite, eval=FALSE}
con.obj <- DBI::dbConnect(RSQLite::SQLite(), dbname = "~/Workspace/TOBIAS.dr.h12_210324.sqlite")
```

```{r Example of fetching factors give group, gene_name}
group_name <- "GA1_2"
zscore.thr <- 2 
acc.thr <- 0.2

test.tal1 <- extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, gene_name = "Tal1", zscore.thr=zscore.thr,acc.thr = acc.thr)

test.gata2 <- extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, gene_name = "Gata2", zscore.thr=zscore.thr,acc.thr = acc.thr)

test.gata3 <- extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, gene_name = "Gata3", zscore.thr=zscore.thr,acc.thr = acc.thr)

lists <- list(test.tal1,test.gata2,test.gata3)

Reduce(intersect, lists)

TF.tot.count <- get.total.TF.count(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, zscore.thr=zscore.thr,acc.thr = acc.thr)

common.regulator.stat.test(lists, total.TF.count = TF.tot.count, mc.cores = 10)
```

```{r, message=FALSE}
all.genes <- dbGetQuery(con.obj, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]

TF.groups.z2_ac0 <- mclapply(1:length(all.genes),function(i){
  gene_name <- all.genes[i]
  #message_parallel(paste(i,gene_name,sep = ": "))
  extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = "CO1_2", gene_name = gene_name, zscore.thr=2, acc.thr = 0.2)
}, mc.cores = 10)

```

```{r}
pairs_df <- map_df(TF.groups.z2_ac0, get_pairs, .id = "source")

# Ensure V1 and V2 are treated as factors for the xtabs function
pairs_df$V1 <- as.factor(pairs_df$V1)
pairs_df$V2 <- as.factor(pairs_df$V2)

# Count the frequency of each pair, ensuring symmetry in the count
frequency_df <- pairs_df %>%
  group_by(V1, V2) %>%
  summarise(n = n(), .groups = 'drop')

# Convert the frequencies into a matrix
frequency_matrix <- matrix(0, nrow = length(levels(pairs_df$V1)), ncol = length(levels(pairs_df$V2)),
                           dimnames = list(levels(pairs_df$V1), levels(pairs_df$V2)))

# Fill the matrix
for(i in 1:nrow(frequency_df)) {
  frequency_matrix[frequency_df$V1[i], frequency_df$V2[i]] <- frequency_df$n[i]
  frequency_matrix[frequency_df$V2[i], frequency_df$V1[i]] <- frequency_df$n[i]  # Ensure symmetry
}

prop.matrix <- round(frequency_matrix/length(TF.groups.z2_ac0), digits = 3)

# Print the matrix
print(frequency_matrix)
print(prop.matrix)

```

```{r, fig.width=8, fig.height=8}
Heatmap(prop.matrix, 
        clustering_distance_rows = "euclidean",
        clustering_distance_columns = "euclidean",
        clustering_method_rows = "complete",
        clustering_method_columns = "complete",
        row_dend_reorder = TRUE,
        column_dend_reorder = TRUE,  # Disable column clustering
        show_row_names = TRUE,
        show_column_names = TRUE,
        show_row_dend = TRUE,
        show_column_dend = TRUE,
        row_names_gp = gpar(fontsize = 10),
        column_names_gp = gpar(fontsize = 10)
        )

```






```{r}
# Assume tf_sets and tf_co_occurrence are already defined

# Function to calculate selection probabilities for each TF
calculate_selection_probabilities <- function(tf_co_occurrence) {
  # Sum co-occurrence frequencies for each TF
  co_occurrence_sums <- rowSums(tf_co_occurrence)
  
  # Convert sums to probabilities (normalizing)
  selection_probabilities <- co_occurrence_sums / sum(co_occurrence_sums)
  return(selection_probabilities)
}

# Function for weighted sampling of TFs for a gene set, considering co-occurrence
weighted_random_sampling <- function(gene_tf_set, selection_probabilities, n_samples) {
  # Filter selection probabilities to only include TFs in the current gene set
  relevant_probs <- selection_probabilities[names(selection_probabilities) %in% gene_tf_set]
  
  # Perform weighted sampling
  sampled_tfs <- sample(gene_tf_set, size = n_samples, replace = TRUE, prob = relevant_probs)
  return(sampled_tfs)
}

# Calculate selection probabilities
selection_probabilities <- calculate_selection_probabilities(frequency_matrix)

# Example: Weighted random sampling for the first gene set
gene_tf_set <- lists[[1]]  # Assuming you're sampling for the first gene
n_samples <- length(gene_tf_set)  # Number of TFs to sample, can adjust as needed

# Perform weighted random sampling
sampled_tfs <- weighted_random_sampling(gene_tf_set, selection_probabilities, n_samples)

cat("Sampled TFs for the gene set:", toString(sampled_tfs), "\n")

```


```{r}
test.1 <- dbGetQuery(con.obj, 'SELECT * FROM feature WHERE seqnames="chr4" AND start>=114986077 AND end<=115134633')

test.tal1 <- as_tibble(dbGetQuery(con.obj, 'SELECT tb.* FROM tobias as tb, exp as exp, links as links, gene_metadata as gm WHERE tb.features==links.feature AND mean_cons>0.5 AND exp.ensg_id=tb.ensg_id AND (tb.GA1_2_bound=1) AND (exp.GA1_2>1.2) AND links.ensg_id=gm.ensg_id AND gm.gene_name="Tal1" AND links.zscore>0 AND links.feature=tb.features'))

test.gata2 <- as_tibble(dbGetQuery(con.obj, 'SELECT tb.* FROM tobias as tb,feature as ft, exp as exp WHERE ft.seqnames="chr6" AND ft.start>=88103987 AND ft.end<=88301611 AND tb.features==ft.feature AND mean_cons>0.5 AND exp.ensg_id=tb.ensg_id AND (tb.GA1_2_bound=1) AND (exp.GA1_2>1.2)'))

test.gata3 <- as_tibble(dbGetQuery(con.obj, 'SELECT tb.* FROM tobias as tb,feature as ft, exp as exp WHERE ft.seqnames="chr2" AND ft.start>=9834965 AND ft.end<=9996391 AND tb.features==ft.feature AND mean_cons>0.5 AND exp.ensg_id=tb.ensg_id AND (tb.GA1_2_bound=1) AND (exp.GA1_2>1.2)'))


intersect(intersect(test.gata2 %>% distinct(TF_gene_name) %>% pull(TF_gene_name), test.tal1 %>% distinct(TF_gene_name) %>% pull(TF_gene_name)),test.gata3 %>% distinct(TF_gene_name) %>% pull(TF_gene_name))


```

```{r}
tobias.table <- tbl(con.obj, "tobias")
exp.table <- tbl(con.obj, "exp")
acc.table <- tbl(con.obj, "acc")

table.tmp.1 <- dplyr::filter(tobias.table, features==feature.coords) %>% left_join(exp.table) %>% left_join(acc.table, by=c("features"="features"))

table.tmp.2 <- table.tmp.1 %>% collect()
  
table.tmp.2 <- table.tmp.2 %>% filter((abs(PRO1_2.x)>exp.thr | abs(CO1_2.x)>exp.thr | abs(GA1_2.x)>exp.thr) & (PRO1_2_bound==1 | CO1_2_bound==1 | GA1_2_bound==1) & mean_cons>mean_cons_thr) %>% arrange(start)
  
```

```{r, eval=FALSE}
acc.table <- tbl(con.obj, "acc")

min.acc <- min(pull(acc.table,CO1_2))
max.acc <- max(pull(acc.table,CO1_2))
acc.steps <- seq(min.acc,max.acc, by=0.25)

bound.ratios <- lapply(acc.steps[-1],function(step){
  bound.query <- paste("SELECT SUM(CASE WHEN tb.CO1_2_bound=1 THEN 1 ELSE 0 END) AS Bounds, SUM(CASE WHEN tb.CO1_2_bound=0 THEN 1 ELSE 0 END) AS Unbounds FROM tobias as tb, acc as ac WHERE ac.features=tb.features AND ac.CO1_2 BETWEEN",step-0.25,"AND",step,";",sep=" ")
  as_tibble(dbGetQuery(con, bound.query))
})

saveRDS(bound.ratios, file="../analysis/bound.ratios.Rds")
```

```{r}
bound.ratios.tb <- as_tibble(do.call(rbind,bound.ratios))
bound.ratios.tb$ratio <- bound.ratios.tb$Bounds/bound.ratios.tb$Unbounds
bound.ratios.tb$acc_range <- factor(paste(acc.steps-0.25,acc.steps,sep="-")[-1])

df_long <- bound.ratios.tb %>% pivot_longer(cols = c(Bounds, Unbounds), names_to = "Type", values_to = "Value")
df_long$Value <- log2(df_long$Value)
df_long$Value[!is.finite(df_long$Value)]<-0
         
ggplot(data = df_long, aes(x = acc_range, y = Value, fill = Type)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_line(data = df_long, aes(x = acc_range, y = ratio, group = 1), color = "blue", linetype = "dashed") +
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Ratio")) +
  labs(y = "Value", x = "Accessibility") +
  theme_minimal() + ylab("log2(count)") + ggtitle("Bound/Unboud counts in CO1_2 per Acc range")
```

```{r}
bound.ratios.tb <- as_tibble(do.call(rbind,bound.ratios))
bound.ratios.tb$ratio <- bound.ratios.tb$Bounds/bound.ratios.tb$Unbounds
bound.ratios.tb$acc_range <- factor(paste(acc.steps-0.25,acc.steps,sep="-")[-1])

df_long <- bound.ratios.tb %>% pivot_longer(cols = c(Bounds, Unbounds), names_to = "Type", values_to = "Value")

ggplot(data = df_long, aes(x = acc_range, y = Value, fill = Type)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_line(data = df_long, aes(x = acc_range, y = ratio, group = 1), color = "blue", linetype = "dashed") +
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Ratio")) +
  labs(y = "Value", x = "Accessibility") +
  theme_minimal() + ylab("Count") + ggtitle("Bound/Unboud counts in CO1_2 per Acc range")
```


```{r}

feature <- "chr1-3670394-3672637"

all.features<- na.omit(as.vector(dbGetQuery(con, "SELECT DISTINCT(features) FROM tobias;"))[[1]])

MIs.per.feature <- mclapply(all.features, function(feature){
  feature.fetch.query <- paste("SELECT PRO1_2_bound,CO1_2_bound,GA1_2_bound,GA3_4_bound,GA5_6_bound, GL1_2_bound,GL3_4_bound,GL5_bound, PRO1_2, CO1_2, GA1_2,GA3_4,GA5_6,GL1_2,GL3_4,GL5 FROM tobias as tb, acc as ac WHERE ac.features=tb.features AND tb.features='",feature,"';",sep="")
  feat.data.tmp <- as_tibble(dbGetQuery(con, feature.fetch.query))
    
  MIs.feature <- sapply(1:nrow(feat.data.tmp),function(row.i){
  mut.tmp <- mutinformation(discretize(as.numeric(feat.data.tmp[row.i,9:16]), disc="equalwidth"), Y = as.numeric(feat.data.tmp[row.i,1:8]))
  return(mut.tmp)
  })
  return(MIs.feature)
}, mc.cores=6)


summary(sapply(MIs.per.feature,mean))
hist(sapply(MIs.per.feature,mean), main="Avg. mutual information between bound/unbound and acc. per feature ")

saveRDS(MIs.per.feature,file="../analysis/MIs.per.feature.Rds")
```

```{r}
all.features<- na.omit(as.vector(dbGetQuery(con, "SELECT DISTINCT(features) FROM tobias;"))[[1]])

MIs.score.per.feature <- mclapply(all.features, function(feature){
  feature.fetch.query <- paste("SELECT PRO1_2_score,CO1_2_score,GA1_2_score,GA3_4_score,GA5_6_score, GL1_2_score,GL3_4_score,GL5_score, PRO1_2, CO1_2, GA1_2,GA3_4,GA5_6,GL1_2,GL3_4,GL5 FROM tobias as tb, acc as ac WHERE ac.features=tb.features AND tb.features='",feature,"';",sep="")
  feat.data.tmp <- as_tibble(dbGetQuery(con, feature.fetch.query))
    
  MIs.feature <- sapply(1:nrow(feat.data.tmp),function(row.i){
  mut.tmp <- mutinformation(discretize(as.numeric(feat.data.tmp[row.i,9:16]), disc="equalwidth"), Y = discretize(as.numeric(feat.data.tmp[row.i,1:8], disc="equalwidth")))
  return(mut.tmp)
  })
  return(MIs.feature)
}, mc.cores=6)


summary(sapply(MIs.score.per.feature,mean))

saveRDS(MIs.score.per.feature,file="../analysis/MIs.per.score.feature.Rds")
```

```{r Calculating bound vs unbound relation to acc per TF}
tobias.table <- tbl(con.obj, "tobias")
acc.table <- tbl(con.obj, "acc")

TFs <- tobias.table %>% dplyr::distinct(TF_gene_name) %>% pull(TF_gene_name)

table.tmp.1 <- tobias.table %>% left_join(acc.table, by=c("features"="features"))

table.tmp.acc.range <- acc.table %>% dplyr::select(!starts_with("features")) %>% collect()
min.acc <- min(table.tmp.acc.range)
max.acc <- max(table.tmp.acc.range)
acc.brackets <- round(seq(min.acc, max.acc, by=max.acc/25),digits = 3)

acc.brackets.list <- lapply(1:(length(acc.brackets)-1), function(i) acc.brackets[i:(i+1)])
acc.brackets.list.names <- sapply(acc.brackets.list,paste,collapse="-")

acc.counts.results <- lapply(TFs,function(TF){
  table.tmp.bound <- table.tmp.1 %>% dplyr::filter(TF_gene_name==TF) %>% dplyr::select(ends_with("_bound")) %>% collect()
  table.tmp.acc <- table.tmp.1 %>% dplyr::filter(TF_gene_name==TF) %>% dplyr::select(one_of("PRO1_2","GL3_4","GA5_6","GL5","CO1_2","GA1_2","GA3_4","GL1_2")) %>% collect()

  acc.counts <- lapply(acc.brackets.list, function(bracket) {
    table(table.tmp.bound[table.tmp.acc >= bracket[1] & table.tmp.acc <= bracket[2]])
  })
  names(acc.counts) <- acc.brackets.list.names
  return(acc.counts)
})

names(acc.counts.results) <- TFs
```

```{r, fig.height=46, fig.width=12-}
TF.bound.ratios <- lapply(acc.counts.results, function(r){
  tmp.1 <- sapply(r,function(rr){rr[1]/rr[2]})
  names(tmp.1) <-acc.brackets.list.names
  return(tmp.1)
  })
TF.count.ratios.mat <-do.call(rbind,TF.bound.ratios)


Heatmap(log2(TF.count.ratios.mat), cluster_columns = FALSE, row_names_gp = gpar(fontsize = 3),heatmap_legend_param = list(title = "log2 ratios of Unbound/Bound"))
```

