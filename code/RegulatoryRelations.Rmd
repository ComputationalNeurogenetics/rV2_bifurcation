---
title: "R Notebook of analysis of regulatory relations from fp,acc,exp and C&T data"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    code_folding: hide
---

```{r Packages, message=FALSE}
library(rtracklayer)
library(qs)
library(Seurat)
library(Signac)
library(tidyverse)
library(GenomicRanges)
library(parallel)
library(dbplyr)
library(DBI)
library(ComplexHeatmap)
source("~/Workspace/AuxCode/TOBIAS_tools.R")
```

```{r Additional functions}
message_parallel <- function(...){
  system(sprintf('echo "\n%s\n"', paste0(..., collapse="")))
}
```

```{r Connection to SQLite, eval=FALSE}
dbname <- "~/Workspace/TOBIAS.dr.h12_110424.sqlite"
con.obj <- DBI::dbConnect(RSQLite::SQLite(), dbname = dbname)
```

# Common regulators {.tabset}

```{r Example of fetching factors give group, gene_name, eval=FALSE}
group_name <- "GA1_2"
zscore.thr <- 2 
acc.thr <- 0

test.tal1 <- extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, gene_name = "Tal1", zscore.thr=zscore.thr,acc.thr = acc.thr)

test.gata2 <- extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, gene_name = "Gata2", zscore.thr=zscore.thr,acc.thr = acc.thr)

test.gata3 <- extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, gene_name = "Gata3", zscore.thr=zscore.thr,acc.thr = acc.thr)

lists <- list(test.tal1,test.gata2,test.gata3)

length(Reduce(intersect, lists))

TF.tot.count <- get.total.TF.count(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = group_name, zscore.thr=zscore.thr,acc.thr = acc.thr)

common.regulator.stat.test(lists, total.TF.count = TF.tot.count, mc.cores = 10)
```

```{r Plot Acc among common regulators, eval=FALSE}
CO.p1 <- plotCommonAcc(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = "CO1_2", selector_genes=c("Gata2","Gata3","Tal1"), zscore.thr=zscore.thr,acc.thr = acc.thr)

GA.p1 <- plotCommonAcc(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = "GA1_2", selector_genes=c("Gata2","Gata3","Tal1"), zscore.thr=zscore.thr,acc.thr = acc.thr)
```

## Tal1 regulators
### CO1_2
```{r Tal1 regulators CO1_2}
Tal1.CO1_2 <- fetch.regulators(db.name = dbname, group_name = "CO1_2", gene_name = "Tal1", zscore.abs.thr=2)

create_dt(Tal1.CO1_2)
```
### GA1_2
```{r Tal1 regulators GA1_2}
Tal1.GA1_2 <- fetch.regulators(db.name = dbname, group_name = "GA1_2", gene_name = "Tal1", zscore.abs.thr=2)

create_dt(Tal1.GA1_2)
```
### GL1_2
```{r Tal1 regulators GL1_2}
Tal1.GL1_2 <- fetch.regulators(db.name = dbname, group_name = "GL1_2", gene_name = "Tal1", zscore.abs.thr=2)

create_dt(Tal1.GL1_2)
```

## Gata2 regulators
### CO1_2
```{r Gata2 regulators CO1_2}
Gata2.CO1_2 <- fetch.regulators(db.name = dbname, group_name = "CO1_2", gene_name = "Gata2", zscore.abs.thr=2)

create_dt(Gata2.CO1_2)
```
### GA1_2
```{r Gata2 regulators GA1_2}
Gata2.GA1_2 <- fetch.regulators(db.name = dbname, group_name = "GA1_2", gene_name = "Gata2", zscore.abs.thr=2)

create_dt(Gata2.GA1_2)
```
### GL1_2
```{r Gata2 regulators GL1_2}
Gata2.GL1_2 <- fetch.regulators(db.name = dbname, group_name = "GL1_2", gene_name = "Gata2", zscore.abs.thr=2)

create_dt(Gata2.GL1_2)
```

## Gata3 regulators
### CO1_2
```{r Gata3 regulators CO1_2}
Gata3.CO1_2 <- fetch.regulators(db.name = dbname, group_name = "CO1_2", gene_name = "Gata3", zscore.abs.thr=2)

create_dt(Gata3.CO1_2)
```
### GA1_2
```{r Gata3 regulators GA1_2}
Gata3.GA1_2 <- fetch.regulators(db.name = dbname, group_name = "GA1_2", gene_name = "Gata3", zscore.abs.thr=2)

create_dt(Gata3.GA1_2)
```
### GL1_2
```{r Gata3 regulators GL1_2}
Gata3.GL1_2 <- fetch.regulators(db.name = dbname, group_name = "GL1_2", gene_name = "Gata3", zscore.abs.thr=2)

create_dt(Gata3.GL1_2)
```


## Vsx2 regulators
### CO1_2
```{r Vsx2 regulators CO1_2}
Vsx2.CO1_2 <- fetch.regulators(db.name = dbname, group_name = "CO1_2", gene_name = "Vsx2", zscore.abs.thr=2)

create_dt(Vsx2.CO1_2)
```
### GA1_2
```{r Vsx2 regulators GA1_2}
Vsx2.GA1_2 <- fetch.regulators(db.name = dbname, group_name = "GA1_2", gene_name = "Vsx2", zscore.abs.thr=2)

create_dt(Vsx2.GA1_2)
```
### GL1_2
```{r Vsx2 regulators GL1_2}
Vsx2.GL1_2 <- fetch.regulators(db.name = dbname, group_name = "GL1_2", gene_name = "Vsx2", zscore.abs.thr=2)

create_dt(Vsx2.GL1_2)
```




# TF-TF co-occurence {.tabset}

```{r, message=FALSE, eval=FALSE}
all.genes <- dbGetQuery(con.obj, 'SELECT DISTINCT gene_name FROM gene_metadata as gm, links as li WHERE li.ensg_id=gm.ensg_id AND li.zscore>2;')[,1]

TF.groups.z2_ac0 <- mclapply(1:length(all.genes),function(i){
  gene_name <- all.genes[i]
  #message_parallel(paste(i,gene_name,sep = ": "))
  extract.factors(db.name = "~/Workspace/TOBIAS.dr.h12_210324.sqlite", group_name = "CO1_2", gene_name = gene_name, zscore.thr=2, acc.thr = 0.2)
}, mc.cores = 10)

```

```{r}
pairs_df <- map_df(TF.groups.z2_ac0, get_pairs, .id = "source")

# Ensure V1 and V2 are treated as factors for the xtabs function
pairs_df$V1 <- as.factor(pairs_df$V1)
pairs_df$V2 <- as.factor(pairs_df$V2)

# Count the frequency of each pair, ensuring symmetry in the count
frequency_df <- pairs_df %>%
  group_by(V1, V2) %>%
  summarise(n = n(), .groups = 'drop')

# Convert the frequencies into a matrix
frequency_matrix <- matrix(0, nrow = length(levels(pairs_df$V1)), ncol = length(levels(pairs_df$V2)),
                           dimnames = list(levels(pairs_df$V1), levels(pairs_df$V2)))

# Fill the matrix
for(i in 1:nrow(frequency_df)) {
  frequency_matrix[frequency_df$V1[i], frequency_df$V2[i]] <- frequency_df$n[i]
  frequency_matrix[frequency_df$V2[i], frequency_df$V1[i]] <- frequency_df$n[i]  # Ensure symmetry
}

prop.matrix <- round(frequency_matrix/length(TF.groups.z2_ac0), digits = 3)

# Print the matrix
#print(frequency_matrix)
#print(prop.matrix)

```

```{r, fig.width=8, fig.height=8}
Heatmap(prop.matrix, 
        clustering_distance_rows = "euclidean",
        clustering_distance_columns = "euclidean",
        clustering_method_rows = "complete",
        clustering_method_columns = "complete",
        row_dend_reorder = TRUE,
        column_dend_reorder = TRUE,  # Disable column clustering
        show_row_names = TRUE,
        show_column_names = TRUE,
        show_row_dend = TRUE,
        show_column_dend = TRUE,
        row_names_gp = gpar(fontsize = 10),
        column_names_gp = gpar(fontsize = 10)
        )

```

```{r, eval=FALSE}
# Assume tf_sets and tf_co_occurrence are already defined

# Function to calculate selection probabilities for each TF
calculate_selection_probabilities <- function(tf_co_occurrence) {
  # Sum co-occurrence frequencies for each TF
  co_occurrence_sums <- rowSums(tf_co_occurrence)
  
  # Convert sums to probabilities (normalizing)
  selection_probabilities <- co_occurrence_sums / sum(co_occurrence_sums)
  return(selection_probabilities)
}

# Function for weighted sampling of TFs for a gene set, considering co-occurrence
weighted_random_sampling <- function(gene_tf_set, selection_probabilities, n_samples) {
  # Filter selection probabilities to only include TFs in the current gene set
  relevant_probs <- selection_probabilities[names(selection_probabilities) %in% gene_tf_set]
  
  # Perform weighted sampling
  sampled_tfs <- sample(gene_tf_set, size = n_samples, replace = TRUE, prob = relevant_probs)
  return(sampled_tfs)
}

# Calculate selection probabilities
selection_probabilities <- calculate_selection_probabilities(frequency_matrix)

# Example: Weighted random sampling for the first gene set
gene_tf_set <- lists[[1]]  # Assuming you're sampling for the first gene
n_samples <- length(gene_tf_set)  # Number of TFs to sample, can adjust as needed

# Perform weighted random sampling
sampled_tfs <- weighted_random_sampling(gene_tf_set, selection_probabilities, n_samples)

cat("Sampled TFs for the gene set:", toString(sampled_tfs), "\n")
```

# TOBIAS vs Acc {.tabset}

## MI TOBIAS vs Acc

```{r, eval=FALSE}
acc.table <- tbl(con.obj, "acc")

min.acc <- min(pull(acc.table,CO1_2))
max.acc <- max(pull(acc.table,CO1_2))
acc.steps <- seq(min.acc,max.acc, by=0.25)

bound.ratios <- lapply(acc.steps[-1],function(step){
  bound.query <- paste("SELECT SUM(CASE WHEN tb.CO1_2_bound=1 THEN 1 ELSE 0 END) AS Bounds, SUM(CASE WHEN tb.CO1_2_bound=0 THEN 1 ELSE 0 END) AS Unbounds FROM tobias as tb, acc as ac WHERE ac.features=tb.features AND ac.CO1_2 BETWEEN",step-0.25,"AND",step,";",sep=" ")
  as_tibble(dbGetQuery(con, bound.query))
})

saveRDS(bound.ratios, file="../analysis/bound.ratios.Rds")
```

```{r, eval=FALSE}
bound.ratios.tb <- as_tibble(do.call(rbind,bound.ratios))
bound.ratios.tb$ratio <- bound.ratios.tb$Bounds/bound.ratios.tb$Unbounds
bound.ratios.tb$acc_range <- factor(paste(acc.steps-0.25,acc.steps,sep="-")[-1])

df_long <- bound.ratios.tb %>% pivot_longer(cols = c(Bounds, Unbounds), names_to = "Type", values_to = "Value")
df_long$Value <- log2(df_long$Value)
df_long$Value[!is.finite(df_long$Value)]<-0
         
ggplot(data = df_long, aes(x = acc_range, y = Value, fill = Type)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_line(data = df_long, aes(x = acc_range, y = ratio, group = 1), color = "blue", linetype = "dashed") +
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Ratio")) +
  labs(y = "Value", x = "Accessibility") +
  theme_minimal() + ylab("log2(count)") + ggtitle("Bound/Unboud counts in CO1_2 per Acc range")
```

```{r, eval=FALSE}
bound.ratios.tb <- as_tibble(do.call(rbind,bound.ratios))
bound.ratios.tb$ratio <- bound.ratios.tb$Bounds/bound.ratios.tb$Unbounds
bound.ratios.tb$acc_range <- factor(paste(acc.steps-0.25,acc.steps,sep="-")[-1])

df_long <- bound.ratios.tb %>% pivot_longer(cols = c(Bounds, Unbounds), names_to = "Type", values_to = "Value")

ggplot(data = df_long, aes(x = acc_range, y = Value, fill = Type)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_line(data = df_long, aes(x = acc_range, y = ratio, group = 1), color = "blue", linetype = "dashed") +
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "Ratio")) +
  labs(y = "Value", x = "Accessibility") +
  theme_minimal() + ylab("Count") + ggtitle("Bound/Unboud counts in CO1_2 per Acc range")
```

```{r, eval=FALSE}
feature <- "chr1-3670394-3672637"

all.features<- na.omit(as.vector(dbGetQuery(con, "SELECT DISTINCT(features) FROM tobias;"))[[1]])

MIs.per.feature <- mclapply(all.features, function(feature){
  feature.fetch.query <- paste("SELECT PRO1_2_bound,CO1_2_bound,GA1_2_bound,GA3_4_bound,GA5_6_bound, GL1_2_bound,GL3_4_bound,GL5_bound, PRO1_2, CO1_2, GA1_2,GA3_4,GA5_6,GL1_2,GL3_4,GL5 FROM tobias as tb, acc as ac WHERE ac.features=tb.features AND tb.features='",feature,"';",sep="")
  feat.data.tmp <- as_tibble(dbGetQuery(con, feature.fetch.query))
    
  MIs.feature <- sapply(1:nrow(feat.data.tmp),function(row.i){
  mut.tmp <- mutinformation(discretize(as.numeric(feat.data.tmp[row.i,9:16]), disc="equalwidth"), Y = as.numeric(feat.data.tmp[row.i,1:8]))
  return(mut.tmp)
  })
  return(MIs.feature)
}, mc.cores=6)


summary(sapply(MIs.per.feature,mean))
hist(sapply(MIs.per.feature,mean), main="Avg. mutual information between bound/unbound and acc. per feature ")

saveRDS(MIs.per.feature,file="../analysis/MIs.per.feature.Rds")
```

```{r, eval=FALSE}
all.features<- na.omit(as.vector(dbGetQuery(con, "SELECT DISTINCT(features) FROM tobias;"))[[1]])

MIs.score.per.feature <- mclapply(all.features, function(feature){
  feature.fetch.query <- paste("SELECT PRO1_2_score,CO1_2_score,GA1_2_score,GA3_4_score,GA5_6_score, GL1_2_score,GL3_4_score,GL5_score, PRO1_2, CO1_2, GA1_2,GA3_4,GA5_6,GL1_2,GL3_4,GL5 FROM tobias as tb, acc as ac WHERE ac.features=tb.features AND tb.features='",feature,"';",sep="")
  feat.data.tmp <- as_tibble(dbGetQuery(con, feature.fetch.query))
    
  MIs.feature <- sapply(1:nrow(feat.data.tmp),function(row.i){
  mut.tmp <- mutinformation(discretize(as.numeric(feat.data.tmp[row.i,9:16]), disc="equalwidth"), Y = discretize(as.numeric(feat.data.tmp[row.i,1:8], disc="equalwidth")))
  return(mut.tmp)
  })
  return(MIs.feature)
}, mc.cores=6)


summary(sapply(MIs.score.per.feature,mean))

saveRDS(MIs.score.per.feature,file="../analysis/MIs.per.score.feature.Rds")
```

## Calculating bound vs unbound relation to acc per TF

```{r Calculating bound vs unbound relation to acc per TF}
tobias.table <- tbl(con.obj, "tobias")
acc.table <- tbl(con.obj, "acc")

TFs <- tobias.table %>% dplyr::distinct(TF_gene_name) %>% pull(TF_gene_name)

table.tmp.1 <- tobias.table %>% left_join(acc.table, by=c("features"="features"))

table.tmp.acc.range <- acc.table %>% dplyr::select(!starts_with("features")) %>% collect()
min.acc <- min(table.tmp.acc.range)
max.acc <- max(table.tmp.acc.range)
acc.brackets <- round(seq(min.acc, max.acc, by=max.acc/25),digits = 3)

acc.brackets.list <- lapply(1:(length(acc.brackets)-1), function(i) acc.brackets[i:(i+1)])
acc.brackets.list.names <- sapply(acc.brackets.list,paste,collapse="-")

acc.counts.results <- lapply(TFs,function(TF){
  table.tmp.bound <- table.tmp.1 %>% dplyr::filter(TF_gene_name==TF) %>% dplyr::select(ends_with("_bound")) %>% collect()
  table.tmp.acc <- table.tmp.1 %>% dplyr::filter(TF_gene_name==TF) %>% dplyr::select(one_of("PRO1_2","GL3_4","GA5_6","GL5","CO1_2","GA1_2","GA3_4","GL1_2")) %>% collect()

  acc.counts <- lapply(acc.brackets.list, function(bracket) {
    table(table.tmp.bound[table.tmp.acc >= bracket[1] & table.tmp.acc <= bracket[2]])
  })
  names(acc.counts) <- acc.brackets.list.names
  return(acc.counts)
})

names(acc.counts.results) <- TFs
```

```{r, fig.height=46, fig.width=12}
TF.bound.ratios <- lapply(acc.counts.results, function(r){
  tmp.1 <- sapply(r,function(rr){rr[1]/rr[2]})
  names(tmp.1) <-acc.brackets.list.names
  return(tmp.1)
  })
TF.count.ratios.mat <-log2(do.call(rbind,TF.bound.ratios))

na.li <- is.na(TF.count.ratios.mat)

TF.count.ratios.mat[na.li] <- 0

dissimilarity_matrix <- dist(TF.count.ratios.mat)

kmeans.stats <- lapply(2:20,function(ci){
  kmeans.TFs <- kmeans(TF.count.ratios.mat, centers = ci, nstart = 25)
  cluster_stats <- cluster.stats(dissimilarity_matrix, kmeans.TFs$cluster)
  return(cluster_stats)
})

kmeans.TFs <- kmeans(TF.count.ratios.mat, centers = 15, nstart = 25)
TF.count.ratios.mat[na.li] <- NA

Heatmap(TF.count.ratios.mat, cluster_columns = FALSE, row_names_gp = gpar(fontsize = 3),heatmap_legend_param = list(title = "log2 ratios of Unbound/Bound"), split = kmeans.TFs$cluster)

pdf(file="../analysis/log2_unbound_bound_ratios_heatmap.pdf", width = 12, height = 46)
  p1 <- Heatmap(TF.count.ratios.mat, cluster_columns = FALSE, row_names_gp = gpar(fontsize = 3),heatmap_legend_param = list(title = "log2 ratios of Unbound/Bound"), split = kmeans.TFs$cluster)
p1
dev.off()
```

```{r}
library(RColorBrewer)
TF.tb <- cbind(as_tibble(TF.count.ratios.mat),cluster=as.character(kmeans.TFs$cluster))
TF.tb.long <- TF.tb %>% pivot_longer(names_to = "acc_range", values_to = "bound_ratio", cols = !starts_with("cluster"))
TF.aveg.long <-  TF.tb.long %>% group_by(cluster, acc_range) %>% summarise(avg=mean(bound_ratio,na.rm=T))

color_palette <- my_colors <- c("#e6194B", "#3cb44b", "#ffe119", "#4363d8", "#f58231", 
               "#911eb4", "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", 
               "#008080", "#e6beff", "#9a6324", "#fffac8", "#800000")


ggplot(TF.aveg.long, aes(x = acc_range, y = avg, color = cluster)) + 
  geom_line(aes(group = cluster)) +
  theme_minimal() +
  geom_point() +
  scale_color_manual(values = color_palette) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "log2(unbound/bound) per TF group over Acc-ranges",
       x = "Acc-ranges",
       y = "log2(unbound/bound)",
       color = "Group",
fill="Group")
```

